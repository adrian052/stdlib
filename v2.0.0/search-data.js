window.Aiken.initSearch([{"doc":"aiken/math","title":"abs","content":"abs(self: Int) -&gt; Int\n Calculate the absolute value of an integer.\n\n ```aiken\n math.abs(-42) == 42\n math.abs(14) == 14\n ```","url":"aiken/math.html#abs"},{"doc":"aiken/math","title":"clamp","content":"clamp(self: Int, min: Int, max: Int) -&gt; Int\n Restrict the value of an integer between two min and max bounds\n\n ```aiken\n math.clamp(14, min: 0, max: 10) == 10\n ```","url":"aiken/math.html#clamp"},{"doc":"aiken/math","title":"gcd","content":"gcd(x: Int, y: Int) -&gt; Int\n The greatest common divisor of two integers.\n\n ```aiken\n math.gcd(42, 14) == 14\n math.gcd(14, 42) == 14\n math.gcd(0, 0) == 0\n ```","url":"aiken/math.html#gcd"},{"doc":"aiken/math","title":"is_sqrt","content":"is_sqrt(self: Int, x: Int) -&gt; Bool\n Checks if an integer has a given integer square root x.\n The check has constant time complexity $O(1)$.\n\n ```aiken\n math.is_sqrt(0, 0)\n math.is_sqrt(25, 5)\n !math.is_sqrt(25, -5)\n math.is_sqrt(44203, 210)\n ```","url":"aiken/math.html#is_sqrt"},{"doc":"aiken/math","title":"log","content":"log(self: Int, base: Int) -&gt; Int\n The logarithm in base `b` of an element using integer divisions.\n\n ```aiken\n math.log(10, base: 2) == 3\n math.log(42, base: 2) == 5\n math.log(42, base: 3) == 3\n math.log(5, base: 0) == 0\n math.log(4, base: 4) == 1\n math.log(4, base: 42) == 0\n ```","url":"aiken/math.html#log"},{"doc":"aiken/math","title":"log2","content":"log2(x: Int) -&gt; Int\n The integer logarithm in base 2. Faster than [`log`](#log) in this particular case.\n\n ```aiken\n math.log2(1) == 0\n math.log2(2) == 1\n math.log2(3) == 1\n math.log2(4) == 2\n math.log2(256) == 8\n math.log2(257) == 8\n math.log2(511) == 8\n math.log2(1025) == 10\n ```","url":"aiken/math.html#log2"},{"doc":"aiken/math","title":"max","content":"max(a: Int, b: Int) -&gt; Int\n Return the maximum of two integers.","url":"aiken/math.html#max"},{"doc":"aiken/math","title":"min","content":"min(a: Int, b: Int) -&gt; Int\n Return the minimum of two integers.","url":"aiken/math.html#min"},{"doc":"aiken/math","title":"pow","content":"pow(self: Int, e: Int) -&gt; Int\n Calculates a number to the power of `e` using the exponentiation by\n squaring method.\n\n ```aiken\n math.pow(3, 5) == 243\n math.pow(7, 2) == 49\n math.pow(3, -4) == 0\n math.pow(0, 0) == 1\n math.pow(513, 3) == 135005697\n ```","url":"aiken/math.html#pow"},{"doc":"aiken/math","title":"pow2","content":"pow2(e: Int) -&gt; Int\n Calculates the power of 2 for a given exponent `e`. Much cheaper than\n using `pow(2, _)` for small exponents $0 &lt; e &lt; 256$.\n\n ```aiken\n math.pow2(-2) == 0\n math.pow2(0) == 1\n math.pow2(1) == 2\n math.pow2(4) == 16\n math.pow2(42) == 4398046511104\n ```","url":"aiken/math.html#pow2"},{"doc":"aiken/math","title":"sqrt","content":"sqrt(self: Int) -&gt; Option&lt;Int&gt;\n Calculates the square root of an integer using the [Babylonian\n method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method). This returns either the exact result or the smallest integer\n nearest to the square root.\n\n Returns `None` for negative values.\n\n ```aiken\n math.sqrt(0) == Some(0)\n math.sqrt(25) == Some(5)\n math.sqrt(44203) == Some(210)\n math.sqrt(-42) == None\n ```\n\n &gt; [!TIP]\n &gt; This function can be quite expensive to perform on-chain. Prefer using [`is_sqrt`](#is_sqrt) whenever possible.","url":"aiken/math.html#sqrt"},{"doc":"aiken/math","title":"aiken/math","content":" This module contains some basic Math utilities. Standard arithmetic\n operations on integers are available through native operators:\n\n Operator | Description\n ---      | :---\n `+`      | Arithmetic sum\n `-`      | Arithmetic difference\n `/`      | Whole division\n `*`      | Arithmetic multiplication\n `%`      | Remainder by whole division\n\n Here are a few examples:\n\n ```aiken\n 1 + 1   // 2\n 10 - 2  // 8\n 40 / 14 // 2\n 3 * 4   // 12\n 10 % 3  // 1","url":"aiken/math.html"},{"doc":"aiken/collection","title":"Index","content":"Index = Int\n An positive integer, that materializes the position of an element in a\n collection.\n","url":"aiken/collection.html#Index"},{"doc":"aiken/collection","title":"aiken/collection","content":"","url":"aiken/collection.html"},{"doc":"aiken/primitive/string","title":"from_bytearray","content":"from_bytearray(bytes: ByteArray) -&gt; String\n Convert a `ByteArray` into a `String`\n\n &gt; [!WARNING]\n &gt; This functions fails if the underlying `ByteArray` isn&#39;t UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n &gt;\n &gt; For converting arbitrary `ByteArray`s, use [bytearray.to_hex](./bytearray.html#to_hex).\n\n ```aiken\n string.from_bytearray(&quot;foo&quot;) == @&quot;foo&quot;\n string.from_bytearray(#&quot;666f6f&quot;) == @&quot;foo&quot;\n string.from_bytearray(some_hash) -&gt; fail\n ```","url":"aiken/primitive/string.html#from_bytearray"},{"doc":"aiken/primitive/string","title":"from_int","content":"from_int(n: Int) -&gt; String\n Convert an `Int` to its `String` representation.\n\n ```aiken\n string.from_int(42) == @&quot;42&quot;\n ```","url":"aiken/primitive/string.html#from_int"},{"doc":"aiken/primitive/string","title":"concat","content":"concat(left: String, right: String) -&gt; String\n Combine two `String` together.\n\n ```aiken\n string.concat(left: @&quot;Hello&quot;, right: @&quot;, World!&quot;) == @&quot;Hello, World!&quot;\n ```","url":"aiken/primitive/string.html#concat"},{"doc":"aiken/primitive/string","title":"join","content":"join(list: List&lt;String&gt;, delimiter: String) -&gt; String\n Join a list of strings, separated by a given _delimiter_.\n\n ```aiken\n string.join([], @&quot;+&quot;) == @&quot;&quot;\n string.join([@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;], @&quot;,&quot;) == @&quot;a,b,c&quot;\n ```","url":"aiken/primitive/string.html#join"},{"doc":"aiken/primitive/string","title":"to_bytearray","content":"to_bytearray(self: String) -&gt; ByteArray\n Convert a `String` into a `ByteArray`\n\n ```aiken\n string.to_bytearray(@&quot;foo&quot;) == &quot;foo&quot;\n ```","url":"aiken/primitive/string.html#to_bytearray"},{"doc":"aiken/primitive/string","title":"aiken/primitive/string","content":"","url":"aiken/primitive/string.html"},{"doc":"aiken/interval","title":"after","content":"after(lower_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values greater than the given bound. i.e [lower_bound, +INF)\n\n ```aiken\n interval.after(10) == Interval {\n   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\n   upper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n }\n ```","url":"aiken/interval.html#after"},{"doc":"aiken/interval","title":"entirely_after","content":"entirely_after(lower_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values after (and not including) the given bound. i.e (lower_bound, +INF)\n\n ```aiken\n interval.entirely_after(10) == Interval {\n   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n   upper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n }\n ```","url":"aiken/interval.html#entirely_after"},{"doc":"aiken/interval","title":"before","content":"before(upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values before (and including) the given bound. i.e (-INF, upper_bound]\n\n ```aiken\n interval.before(100) == Interval {\n   lower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\n   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n }\n ```","url":"aiken/interval.html#before"},{"doc":"aiken/interval","title":"entirely_before","content":"entirely_before(upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values before (and not including) the given bound. i.e (-INF, upper_bound)\n\n ```aiken\n interval.entirely_before(10) == Interval {\n   lower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\n   upper_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n }\n ```","url":"aiken/interval.html#entirely_before"},{"doc":"aiken/interval","title":"between","content":"between(lower_bound: a, upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values between two bounds, including the bounds. i.e. [lower_bound, upper_bound]\n\n ```aiken\n interval.between(10, 100) == Interval {\n   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\n   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n }\n ```","url":"aiken/interval.html#between"},{"doc":"aiken/interval","title":"entirely_between","content":"entirely_between(lower_bound: a, upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values between two bounds, excluding the bounds. i.e. (lower_bound, upper_bound)\n\n ```aiken\n interval.entirely_between(10, 100) == Interval {\n   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n }\n ```","url":"aiken/interval.html#entirely_between"},{"doc":"aiken/interval","title":"empty","content":"empty() -&gt; Interval&lt;a&gt;\n Create an empty interval that contains no value.\n\n ```aiken\n interval.contains(empty(), 0) == False\n interval.contains(empty(), 1000) == False\n ```","url":"aiken/interval.html#empty"},{"doc":"aiken/interval","title":"everything","content":"everything() -&gt; Interval&lt;a&gt;\n Create an interval that contains every possible values. i.e. (-INF, +INF)\n\n ```aiken\n interval.contains(everything(), 0) == True\n interval.contains(everything(), 1000) == True\n ```","url":"aiken/interval.html#everything"},{"doc":"aiken/interval","title":"contains","content":"contains(self: Interval&lt;Int&gt;, elem: Int) -&gt; Bool\n Checks whether an element is contained within the interval.\n\n ```aiken\n let iv =\n   Interval {\n     lower_bound: IntervalBound {\n       bound_type: Finite(14),\n       is_inclusive: True\n     },\n     upper_bound: IntervalBound {\n       bound_type: Finite(42),\n       is_inclusive: False\n     },\n   }\n\n interval.contains(iv, 25) == True\n interval.contains(iv, 0) == False\n interval.contains(iv, 14) == True\n interval.contains(iv, 42) == False\n ```","url":"aiken/interval.html#contains"},{"doc":"aiken/interval","title":"is_empty","content":"is_empty(self: Interval&lt;Int&gt;) -&gt; Bool\n Tells whether an interval is empty; i.e. that is contains no value.\n\n ```aiken\n let iv1 = interval.empty()\n\n let iv2 = Interval {\n     lower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n     upper_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n   }\n\n let iv3 = Interval {\n     lower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n     upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n   }\n\n interval.is_empty(iv1) == True\n interval.is_empty(iv2) == True\n interval.is_empty(iv3) == False\n\n // Note: Two empty intervals are not necessarily equal.\n iv1 != iv2\n ```","url":"aiken/interval.html#is_empty"},{"doc":"aiken/interval","title":"is_entirely_after","content":"is_entirely_after(self: Interval&lt;Int&gt;, point: Int) -&gt; Bool\n Check whether the interval is entirely after the point &quot;a&quot;\n\n ```aiken\n interval.is_entirely_after(interval.after(10), 5) == True\n interval.is_entirely_after(interval.after(10), 10) == False\n interval.is_entirely_after(interval.after(10), 15) == False\n interval.is_entirely_after(interval.between(10, 20), 30) == False\n interval.is_entirely_after(interval.between(10, 20), 5) == True","url":"aiken/interval.html#is_entirely_after"},{"doc":"aiken/interval","title":"is_entirely_before","content":"is_entirely_before(self: Interval&lt;Int&gt;, point: Int) -&gt; Bool\n Check whether the interval is entirely before the point &quot;a&quot;\n\n ```aiken\n interval.is_entirely_before(interval.before(10), 15) == True\n interval.is_entirely_before(interval.before(10), 10) == False\n interval.is_entirely_before(interval.before(10), 5) == False\n interval.is_entirely_before(interval.between(10, 20), 30) == True\n interval.is_entirely_before(interval.between(10, 20), 5) == False","url":"aiken/interval.html#is_entirely_before"},{"doc":"aiken/interval","title":"hull","content":"hull(iv1: Interval&lt;Int&gt;, iv2: Interval&lt;Int&gt;) -&gt; Interval&lt;Int&gt;\n Computes the smallest interval containing the two given intervals, if any\n\n ```aiken\n let iv1 = between(0, 10)\n let iv2 = between(2, 14)\n hull(iv1, iv2) == between(0, 14)\n\n let iv1 = between(5, 10)\n let iv2 = before(0)\n hull(iv1, iv2) == before(10)\n\n let iv1 = entirely_after(0)\n let iv2 = between(10, 42)\n hull(iv1, iv2) = entirely_after(0)\n ```","url":"aiken/interval.html#hull"},{"doc":"aiken/interval","title":"intersection","content":"intersection(iv1: Interval&lt;Int&gt;, iv2: Interval&lt;Int&gt;) -&gt; Interval&lt;Int&gt;\n Computes the largest interval contains in the two given intervals, if any.\n\n ```aiken\n let iv1 = interval.between(0, 10)\n let iv2 = interval.between(2, 14)\n interval.intersection(iv1, iv2) == interval.between(2, 10)\n\n let iv1 = interval.entirely_before(10)\n let iv2 = interval.entirely_after(0)\n interval.intersection(iv1, iv2) == interval.entirely_between(0, 10)\n\n let iv1 = interval.between(0, 1)\n let iv2 = interval.between(2, 3)\n interval.intersection(iv1, iv2) |&gt; interval.is_empty\n ```","url":"aiken/interval.html#intersection"},{"doc":"aiken/interval","title":"max","content":"max(left: IntervalBound&lt;Int&gt;, right: IntervalBound&lt;Int&gt;) -&gt; IntervalBound&lt;Int&gt;\n Return the highest bound of the two.\n\n ```aiken\n let ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\n let ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n\n interval.max(ib1, ib2) == ib2\n ```","url":"aiken/interval.html#max"},{"doc":"aiken/interval","title":"min","content":"min(left: IntervalBound&lt;Int&gt;, right: IntervalBound&lt;Int&gt;) -&gt; IntervalBound&lt;Int&gt;\n Return the smallest bound of the two.\n\n ```aiken\n let ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\n let ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n\n interval.min(ib1, ib2) == ib1\n ```","url":"aiken/interval.html#min"},{"doc":"aiken/interval","title":"Interval","content":"Interval&lt;a&gt; {\n  lower_bound: IntervalBound&lt;a&gt;,\n  upper_bound: IntervalBound&lt;a&gt;,\n}\n A type to represent intervals of values. Interval are inhabited by a type\n `a` which is useful for non-infinite intervals that have a finite\n lower-bound and/or upper-bound.\n\n This allows to represent all kind of mathematical intervals:\n\n ```aiken\n // [1; 10]\n let i0: Interval&lt;PosixTime&gt; = Interval\n   { lower_bound:\n       IntervalBound { bound_type: Finite(1), is_inclusive: True }\n   , upper_bound:\n       IntervalBound { bound_type: Finite(10), is_inclusive: True }\n   }\n ```\n\n ```aiken\n // (20; infinity)\n let i1: Interval&lt;PosixTime&gt; = Interval\n   { lower_bound:\n       IntervalBound { bound_type: Finite(20), is_inclusive: False }\n   , upper_bound:\n       IntervalBound { bound_type: PositiveInfinity, is_inclusive: False }\n   }\n ```\nInterval { lower_bound: IntervalBound&lt;a&gt;, upper_bound: IntervalBound&lt;a&gt; }\n","url":"aiken/interval.html#Interval"},{"doc":"aiken/interval","title":"IntervalBound","content":"IntervalBound&lt;a&gt; {\n  bound_type: IntervalBoundType&lt;a&gt;,\n  is_inclusive: Bool,\n}\n An interval bound, either inclusive or exclusive.\nIntervalBound { bound_type: IntervalBoundType&lt;a&gt;, is_inclusive: Bool }\n","url":"aiken/interval.html#IntervalBound"},{"doc":"aiken/interval","title":"IntervalBoundType","content":"IntervalBoundType&lt;a&gt; {\n  NegativeInfinity\n  Finite(a)\n  PositiveInfinity\n}\n A type of interval bound. Where finite, a value of type `a` must be\n provided. `a` will typically be an `Int`, representing a number of seconds or\n milliseconds.\nNegativeInfinity\n\nFinite(a)\n\nPositiveInfinity\n","url":"aiken/interval.html#IntervalBoundType"},{"doc":"aiken/interval","title":"aiken/interval","content":" In a eUTxO-based blockchain like Cardano, the management of time can be\n finicky.\n\n Indeed, in order to maintain a complete determinism in the execution of\n scripts, it is impossible to introduce a notion of _&quot;current time&quot;_ since\n the execution would then depend on factor that are external to the\n transaction itself: the ineluctable stream of time flowing in our universe.\n\n Hence, to work around that, we typically define time intervals, which gives\n window -- a.k.a intervals -- within which the transaction can be executed.\n From within a script, it isn&#39;t possible to know when exactly the script is\n executed, but we can reason about the interval bounds to validate pieces of\n logic.","url":"aiken/interval.html"},{"doc":"cardano/script_context","title":"ScriptContext","content":"ScriptContext {\n  transaction: Transaction,\n  redeemer: Redeemer,\n  info: ScriptInfo,\n}\n A context given to a script by the Cardano ledger when being executed.\n\n The context contains information about the entire transaction that contains\n the script. The transaction may also contain other scripts; to distinguish\n between multiple scripts, the [`ScriptContext`](#ScriptContext) contains a\n [`ScriptInfo`](#ScriptInfo) which indicates which script (or, for what\n purpose) the transaction is being executed.\nScriptContext { transaction: Transaction, redeemer: Redeemer, info: ScriptInfo }\n","url":"cardano/script_context.html#ScriptContext"},{"doc":"cardano/script_context","title":"ScriptInfo","content":"ScriptInfo {\n  Minting(PolicyId)\n  Spending { output: OutputReference, datum: Option&lt;Data&gt; }\n  Withdrawing(Credential)\n  Publishing { at: Index, certificate: Certificate }\n  Voting(Voter)\n  Proposing { at: Index, proposal_procedure: ProposalProcedure }\n}\n Characterizes the script information. The main (and only) difference with [`ScriptPurpose`](./transaction.html#ScriptPurpose) resides in the `Spending` variant which here contains a second field `datum: Option&lt;Data&gt;`.\nMinting(PolicyId)\n For scripts executed as minting/burning policies, to insert\n or remove assets from circulation. It&#39;s parameterized by the identifier\n of the associated policy.\nSpending { output: OutputReference, datum: Option&lt;Data&gt; }\n For scripts that are used as payment credentials for addresses in\n transaction outputs. They govern the rule by which the output they\n reference can be spent.\nWithdrawing(Credential)\n For scripts that validate reward withdrawals from a reward account.\n\n The argument identifies the target reward account.\nPublishing { at: Index, certificate: Certificate }\n Needed when delegating to a pool using stake credentials defined as a\n custom script. This purpose is also triggered when de-registering such\n stake credentials.\n\n The Int is a 0-based index of the given `Certificate` in `certificates`.\nVoting(Voter)\n Voting for a type of voter using a governance action id to vote\n yes / no / abstain inside a transaction.\n\n The voter is who is doing the governance action.\nProposing { at: Index, proposal_procedure: ProposalProcedure }\n Used to propose a governance action.\n\n A 0-based index of the given `ProposalProcedure` in `proposal_procedures`.","url":"cardano/script_context.html#ScriptInfo"},{"doc":"cardano/script_context","title":"cardano/script_context","content":" This module contains utilities for manually dealing with [`ScriptContext`](#ScriptContext). This is only ever useful for writing custom `else` handlers in validators.\n\n &gt; [!NOTE]\n &gt; Unless you know what you&#39;re doing, you should prefer using named handlers:\n &gt;\n &gt; - `mint`\n &gt; - `spend`\n &gt; - `withdraw`\n &gt; - `publish`\n &gt; - `vote`\n &gt; - `propose`","url":"cardano/script_context.html"},{"doc":"aiken/primitive/bytearray","title":"from_int_big_endian","content":"from_int_big_endian(self: Int, size: Int) -&gt; ByteArray\n Encode an integer value as a Big-Endian (most-significant bytes first) `ByteArray`.\n The size is the expected size in number of bytes.\n\n &gt; [!IMPORTANT]\n &gt; This function halts the program if the value cannot fit in the given size. When the\n &gt; size is _too large_, the array is left-padded with zeroes.\n\n ```aiken\n bytearray.from_int_big_endian(1_000_000, 3) == #&quot;0f4240&quot;\n bytearray.from_int_big_endian(1_000_000, 5) == #&quot;00000f4240&quot;\n bytearray.from_int_big_endian(0, 8) == #&quot;0000000000000000&quot;\n bytearray.from_int_big_endian(1_000_000, 1) =&gt; 💥\n ```","url":"aiken/primitive/bytearray.html#from_int_big_endian"},{"doc":"aiken/primitive/bytearray","title":"from_int_little_endian","content":"from_int_little_endian(self: Int, size: Int) -&gt; ByteArray\n Encode an integer value as a Little-Endian (least-significant bytes first) `ByteArray`.\n The size is the expected size in number of bytes.\n\n &gt; [!IMPORTANT]\n &gt; This function halts the program if the value cannot fit in the given size. When the\n &gt; size is _too large_, the array is right-padded with zeroes.\n\n ```aiken\n bytearray.from_int_big_endian(1_000_000, 3) == #&quot;0f4240&quot;\n bytearray.from_int_big_endian(1_000_000, 5) == #&quot;00000f4240&quot;\n bytearray.from_int_big_endian(0, 8) == #&quot;0000000000000000&quot;\n bytearray.from_int_big_endian(1_000_000, 1) =&gt; 💥\n ```","url":"aiken/primitive/bytearray.html#from_int_little_endian"},{"doc":"aiken/primitive/bytearray","title":"from_string","content":"from_string(str: String) -&gt; ByteArray\n Convert a `String` into a `ByteArray`.\n\n ```aiken\n bytearray.from_string(@&quot;ABC&quot;) == #&quot;414243&quot;\n ```","url":"aiken/primitive/bytearray.html#from_string"},{"doc":"aiken/primitive/bytearray","title":"push","content":"push(self: ByteArray, byte: Byte) -&gt; ByteArray\n Add a byte element in front of a `ByteArray`. When the given byte is\n greater than 255, it wraps-around. **PlutusV2 behavior** So 256 is mapped to 0, 257 to 1, and so\n forth.\n In PlutusV3 this will error instead of wrapping around.\n\n ```aiken\n bytearray.push(#&quot;&quot;, 0) == #&quot;00&quot;\n bytearray.push(#&quot;0203&quot;, 1) == #&quot;010203&quot;\n bytearray.push(#&quot;0203&quot;, 257) == #&quot;010203&quot;\n ```","url":"aiken/primitive/bytearray.html#push"},{"doc":"aiken/primitive/bytearray","title":"at","content":"at(self: ByteArray, index: Int) -&gt; Byte\n Get the `Byte` at the given index, or crash.\n\n &gt; [!WARNING]\n &gt; This functions halts the program if there&#39;s no byte at the given index.","url":"aiken/primitive/bytearray.html#at"},{"doc":"aiken/primitive/bytearray","title":"index_of","content":"index_of(self: ByteArray, bytes: ByteArray) -&gt; Option&lt;(Int, Int)&gt;\n Search the start and end positions of a sub-array in a `ByteArray`.\n\n ```aiken\n bytearray.index_of(&quot;Hello, World!&quot;, &quot;World&quot;) == Some((7, 11))\n bytearray.index_of(&quot;Hello, World!&quot;, &quot;foo&quot;) == None\n bytearray.index_of(&quot;Hello, World!&quot;, &quot;!&quot;) == Some((12, 12))\n bytearray.index_of(&quot;Hello, World!&quot;, &quot;o&quot;) == Some((4, 4))\n bytearray.index_of(&quot;Hello, World!&quot;, &quot;Hello, World!&quot;) == Some((0, 12))\n ```","url":"aiken/primitive/bytearray.html#index_of"},{"doc":"aiken/primitive/bytearray","title":"is_empty","content":"is_empty(self: ByteArray) -&gt; Bool\n Returns `True` when the given `ByteArray` is empty.\n\n ```aiken\n bytearray.is_empty(#&quot;&quot;) == True\n bytearray.is_empty(#&quot;00ff&quot;) == False\n ```","url":"aiken/primitive/bytearray.html#is_empty"},{"doc":"aiken/primitive/bytearray","title":"length","content":"length(self: ByteArray) -&gt; Int\n Returns the number of bytes in a `ByteArray`.\n\n ```aiken\n bytearray.length(#[1, 2, 3]) == 3\n ```","url":"aiken/primitive/bytearray.html#length"},{"doc":"aiken/primitive/bytearray","title":"test_bit","content":"test_bit(self: ByteArray, ix: Int) -&gt; Bool\n Checks whether a bit (Most-Significant-Bit first) is set in the given &#39;ByteArray&#39;.\n\n For example, consider the following bytearray: `#&quot;8b765f&quot;`. It can also be written as the\n following bits sequence:\n\n `8`    | `b`    | `7`    | `6`    | `5`    | `f`\n ---    | ---    | ---    | ---    | ---    | ---\n `1000` | `1011` | `0111` | `0110` | `0101` | `1111`\n\n And thus, we have:\n\n ```aiken\n test_bit(#&quot;8b765f&quot;, 0) == True\n test_bit(#&quot;8b765f&quot;, 1) == False\n test_bit(#&quot;8b765f&quot;, 2) == False\n test_bit(#&quot;8b765f&quot;, 3) == False\n test_bit(#&quot;8b765f&quot;, 7) == True\n test_bit(#&quot;8b765f&quot;, 8) == False\n test_bit(#&quot;8b765f&quot;, 20) == True\n test_bit(#&quot;8b765f&quot;, 21) == True\n test_bit(#&quot;8b765f&quot;, 22) == True\n test_bit(#&quot;8b765f&quot;, 23) == True\n ```","url":"aiken/primitive/bytearray.html#test_bit"},{"doc":"aiken/primitive/bytearray","title":"drop","content":"drop(self: ByteArray, n: Int) -&gt; ByteArray\n Returns the suffix of a `ByteArray` after `n` elements.\n\n ```aiken\n bytearray.drop(#[1, 2, 3], n: 2) == #[3]\n ```","url":"aiken/primitive/bytearray.html#drop"},{"doc":"aiken/primitive/bytearray","title":"slice","content":"slice(self: ByteArray, start: Int, end: Int) -&gt; ByteArray\n Extract a `ByteArray` as a slice of another `ByteArray`.\n\n Indexes are 0-based and inclusive.\n\n ```aiken\n bytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]\n ```","url":"aiken/primitive/bytearray.html#slice"},{"doc":"aiken/primitive/bytearray","title":"take","content":"take(self: ByteArray, n: Int) -&gt; ByteArray\n Returns the n-length prefix of a `ByteArray`.\n\n ```aiken\n bytearray.take(#[1, 2, 3], n: 2) == #[1, 2]\n ```","url":"aiken/primitive/bytearray.html#take"},{"doc":"aiken/primitive/bytearray","title":"concat","content":"concat(left: ByteArray, right: ByteArray) -&gt; ByteArray\n Combine two `ByteArray` together.\n\n ```aiken\n bytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]\n ```","url":"aiken/primitive/bytearray.html#concat"},{"doc":"aiken/primitive/bytearray","title":"compare","content":"compare(left: ByteArray, right: ByteArray) -&gt; Ordering\n Compare two bytearrays lexicographically.\n\n ```aiken\n bytearray.compare(#&quot;00&quot;, #&quot;FF&quot;) == Less\n bytearray.compare(#&quot;42&quot;, #&quot;42&quot;) == Equal\n bytearray.compare(#&quot;FF&quot;, #&quot;00&quot;) == Greater\n ```","url":"aiken/primitive/bytearray.html#compare"},{"doc":"aiken/primitive/bytearray","title":"foldl","content":"foldl(self: ByteArray, zero: result, with: fn(Int, result) -&gt; result) -&gt; result\n Left-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n ```aiken\n bytearray.foldl(#&quot;acab&quot;, 0, fn(byte, acc) { acc * 256 + byte }) == 44203\n bytearray.foldl(#[1, 2, 3], #&quot;&quot;, flip(bytearray.push)) == #[3, 2, 1]\n ```","url":"aiken/primitive/bytearray.html#foldl"},{"doc":"aiken/primitive/bytearray","title":"foldr","content":"foldr(self: ByteArray, zero: result, with: fn(Int, result) -&gt; result) -&gt; result\n Right-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n ```aiken\n bytearray.foldr(#&quot;acab&quot;, 0, fn(byte, acc) { acc * 256 + byte }) == 43948\n bytearray.foldl(#[1, 2, 3], #&quot;&quot;, flip(bytearray.push)) == #[1, 2, 3]\n ```","url":"aiken/primitive/bytearray.html#foldr"},{"doc":"aiken/primitive/bytearray","title":"reduce","content":"reduce(self: ByteArray, zero: result, with: fn(result, Int) -&gt; result) -&gt; result\n Reduce bytes in a ByteArray from left to right using the accumulator as left operand.\n Said differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n ```aiken\n bytearray.reduce(#[1,2,3], #[], bytearray.push) == #[3, 2, 1]\n ```","url":"aiken/primitive/bytearray.html#reduce"},{"doc":"aiken/primitive/bytearray","title":"to_int_big_endian","content":"to_int_big_endian(self: ByteArray) -&gt; Int\n Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n\n ```aiken\n bytearray.to_int_big_endian(#&quot;0f4240&quot;) == 1_000_000\n bytearray.to_int_big_endian(#&quot;00000f4240&quot;) == 1_000_000\n bytearray.to_int_big_endian(#&quot;0000000000000000&quot;) == 0\n ```","url":"aiken/primitive/bytearray.html#to_int_big_endian"},{"doc":"aiken/primitive/bytearray","title":"to_int_little_endian","content":"to_int_little_endian(self: ByteArray) -&gt; Int\n Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n\n ```aiken\n bytearray.to_int_big_endian(#&quot;40420f&quot;) == 1_000_000\n bytearray.to_int_big_endian(#&quot;40420f0000&quot;) == 1_000_000\n bytearray.to_int_big_endian(#&quot;0000000000000000&quot;) == 0\n ```","url":"aiken/primitive/bytearray.html#to_int_little_endian"},{"doc":"aiken/primitive/bytearray","title":"to_string","content":"to_string(self: ByteArray) -&gt; String\n Convert a `ByteArray` into a `String`.\n\n &gt; [!WARNING]\n &gt; This functions fails if the underlying `ByteArray` isn&#39;t UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n &gt;\n &gt; For converting arbitrary `ByteArray`s, use [bytearray.to_hex](#to_hex).\n\n ```aiken\n bytearray.to_string(#&quot;414243&quot;) == &quot;ABC&quot;\n bytearray.to_string(some_hash) =&gt; 💥\n ```","url":"aiken/primitive/bytearray.html#to_string"},{"doc":"aiken/primitive/bytearray","title":"to_hex","content":"to_hex(self: ByteArray) -&gt; String\n Encode a `ByteArray` as a hexidecimal `String`.\n\n ```aiken\n bytearray.to_hex(&quot;Hello world!&quot;) == @&quot;48656c6c6f20776f726c6421&quot;\n ```","url":"aiken/primitive/bytearray.html#to_hex"},{"doc":"aiken/primitive/bytearray","title":"Byte","content":"Byte = Int\n\n","url":"aiken/primitive/bytearray.html#Byte"},{"doc":"aiken/primitive/bytearray","title":"aiken/primitive/bytearray","content":"","url":"aiken/primitive/bytearray.html"},{"doc":"aiken/cbor","title":"serialise","content":"serialise(self: Data) -&gt; ByteArray\n Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).\n\n This is particularly useful in combination with hashing functions, as a way\n to obtain a byte representation that matches the serialised representation\n used by the ledger in the context of on-chain code.\n\n Note that the output matches the output of [`diagnostic`](#diagnostic),\n though with a different encoding. [`diagnostic`](#diagnostic) is merely a\n textual representation of the CBOR encoding that is human friendly and\n useful for debugging.\n\n ```aiken\n cbor.serialise(42) == #&quot;182a&quot;\n cbor.serialise(#&quot;a1b2&quot;) == #&quot;42a1b2&quot;\n cbor.serialise([]) == #&quot;80&quot;\n cbor.serialise((1, 2)) == #&quot;9f0102ff&quot;\n cbor.serialise((1, #&quot;ff&quot;, 3)) == #&quot;9f0141ff03ff&quot;\n cbor.serialise([(1, #&quot;ff&quot;)]) == #&quot;a10141ff&quot;\n cbor.serialise(Some(42)) == #&quot;d8799f182aff&quot;\n cbor.serialise(None) == #&quot;d87a80&quot;\n ```","url":"aiken/cbor.html#serialise"},{"doc":"aiken/cbor","title":"diagnostic","content":"diagnostic(self: Data) -&gt; String\n Obtain a String representation of _anything_. This is particularly (and only) useful for tracing\n and debugging. This function is expensive and should not be used in any production code as it\n will very likely explodes the validator&#39;s budget.\n\n The output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)\n of the underlying on-chain binary representation of the data. It&#39;s not as\n easy to read as plain Aiken code, but it is handy for troubleshooting values\n _at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is\n a good idea in the Cardano world.\n\n ```aiken\n cbor.diagnostic(42) == &quot;42&quot;\n cbor.diagnostic(#&quot;a1b2&quot;) == &quot;h&#39;A1B2&#39;&quot;\n cbor.diagnostic([1, 2, 3]) == &quot;[_ 1, 2, 3]&quot;\n cbor.diagnostic([]) == &quot;[]&quot;\n cbor.diagnostic((1, 2)) == &quot;[_ 1, 2]&quot;\n cbor.diagnostic((1, #&quot;ff&quot;, 3)) == &quot;[_ 1, h&#39;FF&#39;, 3]&quot;\n cbor.diagnostic([(1, #&quot;ff&quot;)]) == &quot;{_ 1: h&#39;FF&#39; }&quot;\n cbor.diagnostic(Some(42)) == &quot;121([_ 42])&quot;\n cbor.diagnostic(None) == &quot;122([])&quot;\n ```","url":"aiken/cbor.html#diagnostic"},{"doc":"aiken/cbor","title":"aiken/cbor","content":"","url":"aiken/cbor.html"},{"doc":"cardano/governance","title":"Constitution","content":"Constitution {\n  guardrails: Option&lt;ScriptHash&gt;,\n}\n\nConstitution { guardrails: Option&lt;ScriptHash&gt; }\n","url":"cardano/governance.html#Constitution"},{"doc":"cardano/governance","title":"GovernanceAction","content":"GovernanceAction {\n  ProtocolParameters { ancestor: Option&lt;GovernanceActionId&gt;, new_parameters: ProtocolParametersUpdate, guardrails: Option&lt;ScriptHash&gt; }\n  HardFork { ancestor: Option&lt;GovernanceActionId&gt;, new_version: ProtocolVersion }\n  TreasuryWithdrawal { beneficiaries: Pairs&lt;Credential, Lovelace&gt;, guardrails: Option&lt;ScriptHash&gt; }\n  NoConfidence { ancestor: Option&lt;GovernanceActionId&gt; }\n  ConstitutionalCommittee { ancestor: Option&lt;GovernanceActionId&gt;, evicted_members: List&lt;Credential&gt;, added_members: Pairs&lt;Credential, Mandate&gt;, quorum: Rational }\n  NewConstitution { ancestor: Option&lt;GovernanceActionId&gt;, constitution: Constitution }\n  NicePoll\n}\n\nProtocolParameters {\n  ancestor: Option&lt;GovernanceActionId&gt;,\n  new_parameters: ProtocolParametersUpdate,\n  guardrails: Option&lt;ScriptHash&gt;,\n}\n\nHardFork { ancestor: Option&lt;GovernanceActionId&gt;, new_version: ProtocolVersion }\n\nTreasuryWithdrawal {\n  beneficiaries: Pairs&lt;Credential, Lovelace&gt;,\n  guardrails: Option&lt;ScriptHash&gt;,\n}\n\nNoConfidence { ancestor: Option&lt;GovernanceActionId&gt; }\n\nConstitutionalCommittee {\n  ancestor: Option&lt;GovernanceActionId&gt;,\n  evicted_members: List&lt;Credential&gt;,\n  added_members: Pairs&lt;Credential, Mandate&gt;,\n  quorum: Rational,\n}\n\nNewConstitution {\n  ancestor: Option&lt;GovernanceActionId&gt;,\n  constitution: Constitution,\n}\n\nNicePoll\n","url":"cardano/governance.html#GovernanceAction"},{"doc":"cardano/governance","title":"GovernanceActionId","content":"GovernanceActionId {\n  transaction: TransactionId,\n  proposal_procedure: Index,\n}\n\nGovernanceActionId { transaction: TransactionId, proposal_procedure: Index }\n","url":"cardano/governance.html#GovernanceActionId"},{"doc":"cardano/governance","title":"Mandate","content":"Mandate = Int\n An epoch number after which constitutional committee member\n mandate expires.\n","url":"cardano/governance.html#Mandate"},{"doc":"cardano/governance","title":"ProposalProcedure","content":"ProposalProcedure {\n  deposit: Lovelace,\n  return_address: Credential,\n  governance_action: GovernanceAction,\n}\n\nProposalProcedure {\n  deposit: Lovelace,\n  return_address: Credential,\n  governance_action: GovernanceAction,\n}\n","url":"cardano/governance.html#ProposalProcedure"},{"doc":"cardano/governance","title":"ProtocolVersion","content":"ProtocolVersion {\n  major: Int,\n  minor: Int,\n}\n\nProtocolVersion { major: Int, minor: Int }\n","url":"cardano/governance.html#ProtocolVersion"},{"doc":"cardano/governance","title":"TransactionId","content":"TransactionId = Hash&lt;Blake2b_256, ByteArray&gt;\n\n","url":"cardano/governance.html#TransactionId"},{"doc":"cardano/governance","title":"Vote","content":"Vote {\n  No\n  Yes\n  Abstain\n}\n\nNo\n\nYes\n\nAbstain\n","url":"cardano/governance.html#Vote"},{"doc":"cardano/governance","title":"Voter","content":"Voter {\n  ConstitutionalCommitteeMember(Credential)\n  DelegateRepresentative(Credential)\n  StakePool(VerificationKeyHash)\n}\n\nConstitutionalCommitteeMember(Credential)\n\nDelegateRepresentative(Credential)\n\nStakePool(VerificationKeyHash)\n","url":"cardano/governance.html#Voter"},{"doc":"cardano/governance","title":"cardano/governance","content":"","url":"cardano/governance.html"},{"doc":"cardano/assets","title":"from_asset","content":"from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int) -&gt; Value\n Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)\n and a given quantity.","url":"cardano/assets.html#from_asset"},{"doc":"cardano/assets","title":"from_asset_list","content":"from_asset_list(xs: Pairs&lt;PolicyId, Pairs&lt;AssetName, Int&gt;&gt;) -&gt; Value\n Promote an arbitrary list of assets into a `Value`. This function fails\n (i.e. halt the program execution) if:\n\n - there&#39;s any duplicate amongst `PolicyId`;\n - there&#39;s any duplicate amongst `AssetName`;\n - the `AssetName` aren&#39;t sorted in ascending lexicographic order; or\n - any asset quantity is null.\n\n This function is meant to turn arbitrary user-defined `Data` into safe `Value`,\n while checking for internal invariants.","url":"cardano/assets.html#from_asset_list"},{"doc":"cardano/assets","title":"from_lovelace","content":"from_lovelace(quantity: Int) -&gt; Value\n Construct a `Value` from a lovelace quantity.\n\n Friendly reminder: 1 Ada = 1.000.000 Lovelace","url":"cardano/assets.html#from_lovelace"},{"doc":"cardano/assets","title":"zero","content":"zero() -&gt; Value\n Construct an empty `Value` with nothing in it.","url":"cardano/assets.html#zero"},{"doc":"cardano/assets","title":"is_zero","content":"is_zero(self: Value) -&gt; Bool\n Check is a `Value` is zero. That is, it has no assets and holds no Ada/Lovelace.","url":"cardano/assets.html#is_zero"},{"doc":"cardano/assets","title":"lovelace_of","content":"lovelace_of(self: Value) -&gt; Int\n A specialized version of `quantity_of` for the Ada currency.","url":"cardano/assets.html#lovelace_of"},{"doc":"cardano/assets","title":"policies","content":"policies(self: Value) -&gt; List&lt;PolicyId&gt;\n A list of all token policies in that Value with non-zero tokens.","url":"cardano/assets.html#policies"},{"doc":"cardano/assets","title":"quantity_of","content":"quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName) -&gt; Int\n Extract the quantity of a given asset.","url":"cardano/assets.html#quantity_of"},{"doc":"cardano/assets","title":"tokens","content":"tokens(self: Value, policy_id: PolicyId) -&gt; Dict&lt;AssetName, Int&gt;\n Get all tokens associated with a given policy.","url":"cardano/assets.html#tokens"},{"doc":"cardano/assets","title":"add","content":"add(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -&gt; Value\n Add a (positive or negative) quantity of a single token to a assets.\n This is more efficient than [`merge`](#merge) for a single asset.","url":"cardano/assets.html#add"},{"doc":"cardano/assets","title":"merge","content":"merge(left: Value, right: Value) -&gt; Value\n Combine two `Value` together.","url":"cardano/assets.html#merge"},{"doc":"cardano/assets","title":"negate","content":"negate(self: Value) -&gt; Value\n Negates quantities of all tokens (including Ada) in that `Value`.\n\n ```\n v1\n   |&gt; assets.negate\n   |&gt; assets.merge(v1)\n   |&gt; assets.is_zero\n // True\n ```","url":"cardano/assets.html#negate"},{"doc":"cardano/assets","title":"without_lovelace","content":"without_lovelace(self: Value) -&gt; Value\n Get a `Value` excluding Ada.","url":"cardano/assets.html#without_lovelace"},{"doc":"cardano/assets","title":"flatten","content":"flatten(self: Value) -&gt; List&lt;(PolicyId, AssetName, Int)&gt;\n Flatten a `Value` as list of 3-tuple `(PolicyId, AssetName, Quantity)`.\n\n Handy to manipulate values as uniform lists.","url":"cardano/assets.html#flatten"},{"doc":"cardano/assets","title":"flatten_with","content":"flatten_with(\n  self: Value,\n  with: fn(PolicyId, AssetName, Int) -&gt; Option&lt;result&gt;,\n) -&gt; List&lt;result&gt;\n Flatten a `Value` as a list of results, possibly discarding some along the way.\n\n When the transform function returns `None`, the result is discarded altogether.","url":"cardano/assets.html#flatten_with"},{"doc":"cardano/assets","title":"reduce","content":"reduce(\n  self: Value,\n  start: result,\n  with: fn(PolicyId, AssetName, Int, result) -&gt; result,\n) -&gt; result\n Reduce a value into a single result\n\n ```\n assets.zero()\n  |&gt; assets.add(&quot;a&quot;, &quot;1&quot;, 10)\n  |&gt; assets.add(&quot;b&quot;, &quot;2&quot;, 20)\n  |&gt; assets.reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n // 30\n ```","url":"cardano/assets.html#reduce"},{"doc":"cardano/assets","title":"to_dict","content":"to_dict(self: Value) -&gt; Dict&lt;PolicyId, Dict&lt;AssetName, Int&gt;&gt;\n Convert the value into a dictionary of dictionaries.","url":"cardano/assets.html#to_dict"},{"doc":"cardano/assets","title":"AssetName","content":"AssetName = ByteArray\n A type-alias for &#39;AssetName`, which are free-form byte-arrays between\n 0 and 32 bytes.\n","url":"cardano/assets.html#AssetName"},{"doc":"cardano/assets","title":"Lovelace","content":"Lovelace = Int\n Lovelace is now a type wrapper for Int.\n","url":"cardano/assets.html#Lovelace"},{"doc":"cardano/assets","title":"PolicyId","content":"PolicyId = Hash&lt;Blake2b_224, Script&gt;\n A type-alias for a `PolicyId`. A `PolicyId` is always 28-byte long\n","url":"cardano/assets.html#PolicyId"},{"doc":"cardano/assets","title":"Value","content":"Value\n A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).\n\n &gt; [!IMPORTANT]\n &gt; This type maintain some invariants by construction; in particular, a `Value` will never contain a\n zero quantity of a particular token.\n","url":"cardano/assets.html#Value"},{"doc":"cardano/assets","title":"ada_asset_name","content":"ada_asset_name: ByteArray = &quot;&quot;\n Ada, the native currency, isn&#39;t associated with any `AssetName` (it&#39;s not\n possible to mint Ada!).\n\n By convention, it is an empty `ByteArray`.","url":"cardano/assets.html#ada_asset_name"},{"doc":"cardano/assets","title":"ada_policy_id","content":"ada_policy_id: ByteArray = &quot;&quot;\n Ada, the native currency, isn&#39;t associated with any `PolicyId` (it&#39;s not\n possible to mint Ada!).\n\n By convention, it is an empty `ByteArray`.","url":"cardano/assets.html#ada_policy_id"},{"doc":"cardano/assets","title":"cardano/assets","content":"","url":"cardano/assets.html"},{"doc":"cardano/governance/protocol_parameters","title":"min_fee_coefficient","content":"min_fee_coefficient(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The linear coefficient that intervenes in the transaction fee calculation.\n It is multiplied by the size of the transaction in bytes to obtain a Lovelace value.","url":"cardano/governance/protocol_parameters.html#min_fee_coefficient"},{"doc":"cardano/governance/protocol_parameters","title":"min_fee_constant","content":"min_fee_constant(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The constant factor that intervenes in the transaction fee calculation. It is\n a flat cost of lovelace that is added to every fee calculation.","url":"cardano/governance/protocol_parameters.html#min_fee_constant"},{"doc":"cardano/governance/protocol_parameters","title":"max_block_body_size","content":"max_block_body_size(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The maximum size of a serialized block body, expressed in bytes.","url":"cardano/governance/protocol_parameters.html#max_block_body_size"},{"doc":"cardano/governance/protocol_parameters","title":"max_transaction_size","content":"max_transaction_size(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The maximum size of a serialized transaction (body + witnesses), expressed in bytes.","url":"cardano/governance/protocol_parameters.html#max_transaction_size"},{"doc":"cardano/governance/protocol_parameters","title":"max_block_header_size","content":"max_block_header_size(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The maximum size of a serialized block header, expressed in bytes.","url":"cardano/governance/protocol_parameters.html#max_block_header_size"},{"doc":"cardano/governance/protocol_parameters","title":"stake_credential_deposit","content":"stake_credential_deposit(self: ProtocolParametersUpdate) -&gt; Option&lt;Lovelace&gt;\n The required deposit amount when registering stake credentials, expressed in Lovelace.","url":"cardano/governance/protocol_parameters.html#stake_credential_deposit"},{"doc":"cardano/governance/protocol_parameters","title":"stake_pool_deposit","content":"stake_pool_deposit(self: ProtocolParametersUpdate) -&gt; Option&lt;Lovelace&gt;\n The required deposit amount when registering a stake pool, expressed in Lovelace.","url":"cardano/governance/protocol_parameters.html#stake_pool_deposit"},{"doc":"cardano/governance/protocol_parameters","title":"stake_pool_retirement_horizon","content":"stake_pool_retirement_horizon(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The maximum number of epoch in the future allowed for a stake pool retirement to be scheduled.","url":"cardano/governance/protocol_parameters.html#stake_pool_retirement_horizon"},{"doc":"cardano/governance/protocol_parameters","title":"desired_number_of_stake_pools","content":"desired_number_of_stake_pools(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The desired/optimal number of fully saturated stake pools in the system. Also known as the _&#39;k-parameter&#39;_.","url":"cardano/governance/protocol_parameters.html#desired_number_of_stake_pools"},{"doc":"cardano/governance/protocol_parameters","title":"stake_pool_pledge_influence","content":"stake_pool_pledge_influence(self: ProtocolParametersUpdate) -&gt; Option&lt;Rational&gt;\n A parameter controlling the influence of an pool owner&#39;s pledge on the rewards. Also known as _&#39;a0&#39;_.","url":"cardano/governance/protocol_parameters.html#stake_pool_pledge_influence"},{"doc":"cardano/governance/protocol_parameters","title":"monetary_expansion","content":"monetary_expansion(self: ProtocolParametersUpdate) -&gt; Option&lt;Rational&gt;\n The monetary expansion parameter, controlling the fraction of Ada put in circulation on every epoch through the incentivies model. Also known as _&#39;ρ&#39;_.","url":"cardano/governance/protocol_parameters.html#monetary_expansion"},{"doc":"cardano/governance/protocol_parameters","title":"treasury_expansion","content":"treasury_expansion(self: ProtocolParametersUpdate) -&gt; Option&lt;Rational&gt;\n The parameter controlling what fraction (%) of available rewards is sent to the treasury on every epoch. Also known as _&#39;τ&#39;_.","url":"cardano/governance/protocol_parameters.html#treasury_expansion"},{"doc":"cardano/governance/protocol_parameters","title":"min_stake_pool_cost","content":"min_stake_pool_cost(self: ProtocolParametersUpdate) -&gt; Option&lt;Lovelace&gt;\n Minimum authorized constant cost that stake pools can declare when registering, expressed in Lovelace.","url":"cardano/governance/protocol_parameters.html#min_stake_pool_cost"},{"doc":"cardano/governance/protocol_parameters","title":"min_utxo_deposit_coefficient","content":"min_utxo_deposit_coefficient(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The linear coefficient that intervenes in the calculation of the minimum Ada value that any UTxO must hold. It is expressed in Lovelace per Byte, and is also known as the &#39;coins per utxo byte&#39; parameter.","url":"cardano/governance/protocol_parameters.html#min_utxo_deposit_coefficient"},{"doc":"cardano/governance/protocol_parameters","title":"cost_models","content":"cost_models(self: ProtocolParametersUpdate) -&gt; Option&lt;Data&gt;\n The costs associated with the various operations of the Plutus Virtual Machine, which can be different for each Plutus version.","url":"cardano/governance/protocol_parameters.html#cost_models"},{"doc":"cardano/governance/protocol_parameters","title":"script_execution_prices","content":"script_execution_prices(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;ScriptExecutionPrices&gt;\n The price, in Lovelace per unit, of the execution units corresponding to cpu and memory usage of on-chain scripts.","url":"cardano/governance/protocol_parameters.html#script_execution_prices"},{"doc":"cardano/governance/protocol_parameters","title":"max_transaction_execution_units","content":"max_transaction_execution_units(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;ExecutionUnits&gt;\n The maximum execution units allowed for a single transaction.","url":"cardano/governance/protocol_parameters.html#max_transaction_execution_units"},{"doc":"cardano/governance/protocol_parameters","title":"max_block_execution_units","content":"max_block_execution_units(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;ExecutionUnits&gt;\n The maximum execution units allowed for a single block.","url":"cardano/governance/protocol_parameters.html#max_block_execution_units"},{"doc":"cardano/governance/protocol_parameters","title":"max_value_size","content":"max_value_size(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The maximum size of a serialized value in a transaction output. This effectively limits\n the maximum kinds of assets that can be sent in a single output. It is expressed in bytes.","url":"cardano/governance/protocol_parameters.html#max_value_size"},{"doc":"cardano/governance/protocol_parameters","title":"collateral_percentage","content":"collateral_percentage(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The scaling factor applied to the transaction cost for defining the minimum collateral\n amount. It is expressed in percent points (so 100 = 100%).","url":"cardano/governance/protocol_parameters.html#collateral_percentage"},{"doc":"cardano/governance/protocol_parameters","title":"max_collateral_inputs","content":"max_collateral_inputs(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The maximum number of collateral inputs allowed in the transaction.","url":"cardano/governance/protocol_parameters.html#max_collateral_inputs"},{"doc":"cardano/governance/protocol_parameters","title":"stake_pool_operator_voting_thresholds","content":"stake_pool_operator_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;StakePoolOperatorVotingThresholds&gt;\n The various governance voting thresholds pertaining to stake pool operators.","url":"cardano/governance/protocol_parameters.html#stake_pool_operator_voting_thresholds"},{"doc":"cardano/governance/protocol_parameters","title":"delegate_representative_voting_thresholds","content":"delegate_representative_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;DelegateRepresentativeVotingThresholds&gt;\n The various governance voting thresholds pertaining to delegate representatives\n (a.k.a DReps).","url":"cardano/governance/protocol_parameters.html#delegate_representative_voting_thresholds"},{"doc":"cardano/governance/protocol_parameters","title":"min_constitutional_committee_size","content":"min_constitutional_committee_size(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The minimum number of members in the constitutional committee. Any updates of the committee\n must leave at least this number of members.","url":"cardano/governance/protocol_parameters.html#min_constitutional_committee_size"},{"doc":"cardano/governance/protocol_parameters","title":"max_constitutional_committee_mandate","content":"max_constitutional_committee_mandate(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;Int&gt;\n The maximum length of a constitutional committee member, expressed in number of epochs.","url":"cardano/governance/protocol_parameters.html#max_constitutional_committee_mandate"},{"doc":"cardano/governance/protocol_parameters","title":"governance_proposal_lifetime","content":"governance_proposal_lifetime(self: ProtocolParametersUpdate) -&gt; Option&lt;Int&gt;\n The lifetime of any governance proposal. An action that hasn&#39;t been approved beyond that\n period is considered inactive and discarded. It is expressed in number of epochs.","url":"cardano/governance/protocol_parameters.html#governance_proposal_lifetime"},{"doc":"cardano/governance/protocol_parameters","title":"governance_proposal_deposit","content":"governance_proposal_deposit(self: ProtocolParametersUpdate) -&gt; Option&lt;Lovelace&gt;\n The required deposit amount for governance proposal procedures, expressed in Lovelace.","url":"cardano/governance/protocol_parameters.html#governance_proposal_deposit"},{"doc":"cardano/governance/protocol_parameters","title":"delegate_representative_deposit","content":"delegate_representative_deposit(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;Lovelace&gt;\n The required deposit amount when registering as a delegate representative, expressed in\n Lovelace.","url":"cardano/governance/protocol_parameters.html#delegate_representative_deposit"},{"doc":"cardano/governance/protocol_parameters","title":"delegate_representative_max_idle_time","content":"delegate_representative_max_idle_time(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;Int&gt;\n The maximum number of epochs that a delegate representative can stay inactive (i.e. no\n voting) without becoming _inactive_ and removed from thresholds calculations.","url":"cardano/governance/protocol_parameters.html#delegate_representative_max_idle_time"},{"doc":"cardano/governance/protocol_parameters","title":"reference_scripts_tier_fee_initial_factor","content":"reference_scripts_tier_fee_initial_factor(\n  self: ProtocolParametersUpdate,\n) -&gt; Option&lt;Rational&gt;\n The base tier fee coefficient for reference scripts. Reference scripts gets increasingly\n more expensives every ~24KB, the base coefficient is a multiplicating factor which grows\n exponentially with each tier.","url":"cardano/governance/protocol_parameters.html#reference_scripts_tier_fee_initial_factor"},{"doc":"cardano/governance/protocol_parameters","title":"ConstitutionalCommitteeThresholds","content":"ConstitutionalCommitteeThresholds {\n  default: Rational,\n  under_no_confidence: Rational,\n}\n\nConstitutionalCommitteeThresholds {\n  default: Rational,\n  under_no_confidence: Rational,\n}\n","url":"cardano/governance/protocol_parameters.html#ConstitutionalCommitteeThresholds"},{"doc":"cardano/governance/protocol_parameters","title":"DelegateRepresentativeVotingThresholds","content":"DelegateRepresentativeVotingThresholds {\n  motion_of_no_confidence: Rational,\n  constitutional_committee: ConstitutionalCommitteeThresholds,\n  constitution: Rational,\n  hard_fork: Rational,\n  protocol_parameters: ProtocolParametersThresholds&lt;Void, Rational, Rational, Rational, Rational&gt;,\n  treasury_withdrawal: Rational,\n}\n\nDelegateRepresentativeVotingThresholds {\n  motion_of_no_confidence: Rational,\n  constitutional_committee: ConstitutionalCommitteeThresholds,\n  constitution: Rational,\n  hard_fork: Rational,\n  protocol_parameters: ProtocolParametersThresholds&lt;\n    Void,\n    Rational,\n    Rational,\n    Rational,\n    Rational,\n  &gt;,\n  treasury_withdrawal: Rational,\n}\n","url":"cardano/governance/protocol_parameters.html#DelegateRepresentativeVotingThresholds"},{"doc":"cardano/governance/protocol_parameters","title":"ExecutionUnits","content":"ExecutionUnits {\n  memory: Int,\n  cpu: Int,\n}\n\nExecutionUnits { memory: Int, cpu: Int }\n","url":"cardano/governance/protocol_parameters.html#ExecutionUnits"},{"doc":"cardano/governance/protocol_parameters","title":"ProtocolParametersThresholds","content":"ProtocolParametersThresholds&lt;security, network, economic, technical, governance&gt; {\n  security_group: security,\n  network_group: network,\n  economic_group: economic,\n  technical_group: technical,\n  governance_group: governance,\n}\n\nProtocolParametersThresholds {\n  security_group: security,\n  network_group: network,\n  economic_group: economic,\n  technical_group: technical,\n  governance_group: governance,\n}\n","url":"cardano/governance/protocol_parameters.html#ProtocolParametersThresholds"},{"doc":"cardano/governance/protocol_parameters","title":"ProtocolParametersUpdate","content":"ProtocolParametersUpdate\n\n","url":"cardano/governance/protocol_parameters.html#ProtocolParametersUpdate"},{"doc":"cardano/governance/protocol_parameters","title":"ScriptExecutionPrices","content":"ScriptExecutionPrices {\n  memory: Rational,\n  cpu: Rational,\n}\n\nScriptExecutionPrices { memory: Rational, cpu: Rational }\n","url":"cardano/governance/protocol_parameters.html#ScriptExecutionPrices"},{"doc":"cardano/governance/protocol_parameters","title":"StakePoolOperatorVotingThresholds","content":"StakePoolOperatorVotingThresholds {\n  motion_of_no_confidence: Rational,\n  constitutional_committee: ConstitutionalCommitteeThresholds,\n  hard_fork: Rational,\n  protocol_parameters: ProtocolParametersThresholds&lt;Rational, Void, Void, Void, Void&gt;,\n}\n\nStakePoolOperatorVotingThresholds {\n  motion_of_no_confidence: Rational,\n  constitutional_committee: ConstitutionalCommitteeThresholds,\n  hard_fork: Rational,\n  protocol_parameters: ProtocolParametersThresholds&lt;\n    Rational,\n    Void,\n    Void,\n    Void,\n    Void,\n  &gt;,\n}\n","url":"cardano/governance/protocol_parameters.html#StakePoolOperatorVotingThresholds"},{"doc":"cardano/governance/protocol_parameters","title":"cardano/governance/protocol_parameters","content":"","url":"cardano/governance/protocol_parameters.html"},{"doc":"aiken/primitive/int","title":"compare","content":"compare(left: Int, right: Int) -&gt; Ordering\n Compare two integers.\n\n ```aiken\n int.compare(14, 42) == Less\n int.compare(14, 14) == Equal\n int.compare(42, 14) == Greater\n ```","url":"aiken/primitive/int.html#compare"},{"doc":"aiken/primitive/int","title":"from_bytearray_big_endian","content":"from_bytearray_big_endian(self: ByteArray) -&gt; Int\n Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n\n ```aiken\n int.from_bytearray_big_endian(#&quot;0f4240&quot;) == 1_000_000\n int.from_bytearray_big_endian(#&quot;00000f4240&quot;) == 1_000_000\n int.from_bytearray_big_endian(#&quot;0000000000000000&quot;) == 0\n ```","url":"aiken/primitive/int.html#from_bytearray_big_endian"},{"doc":"aiken/primitive/int","title":"from_bytearray_little_endian","content":"from_bytearray_little_endian(self: ByteArray) -&gt; Int\n Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n\n ```aiken\n int.from_bytearray_big_endian(#&quot;40420f&quot;) == 1_000_000\n int.from_bytearray_big_endian(#&quot;40420f0000&quot;) == 1_000_000\n int.from_bytearray_big_endian(#&quot;0000000000000000&quot;) == 0\n ```","url":"aiken/primitive/int.html#from_bytearray_little_endian"},{"doc":"aiken/primitive/int","title":"from_utf8","content":"from_utf8(bytes: ByteArray) -&gt; Option&lt;Int&gt;\n Parse an integer from a utf-8 encoded `ByteArray`, when possible.\n\n ```aiken\n int.from_utf8(&quot;14&quot;) == Some(14)\n int.from_utf8(&quot;-42&quot;) == Some(-42)\n int.from_utf8(&quot;007&quot;) == Some(7)\n int.from_utf8(&quot;foo&quot;) == None\n int.from_utf8(&quot;1.0&quot;) == None\n int.from_utf8(&quot;1-2&quot;) == None\n ```","url":"aiken/primitive/int.html#from_utf8"},{"doc":"aiken/primitive/int","title":"to_string","content":"to_string(n: Int) -&gt; String\n Convert an `Int` to its `String` representation.\n\n ```aiken\n int.to_string(42) == @&quot;42&quot;\n ```","url":"aiken/primitive/int.html#to_string"},{"doc":"aiken/primitive/int","title":"aiken/primitive/int","content":"","url":"aiken/primitive/int.html"},{"doc":"aiken/collection/list","title":"push","content":"push(self: List&lt;a&gt;, elem: a) -&gt; List&lt;a&gt;\n Add an element in front of the list. Sometimes useful when combined with\n other functions.\n\n ```aiken\n list.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]\n ```","url":"aiken/collection/list.html#push"},{"doc":"aiken/collection/list","title":"range","content":"range(from: Int, to: Int) -&gt; List&lt;Int&gt;\n Construct a list of a integer from a given range.\n\n ```aiken\n list.range(0, 3) == [0, 1, 2, 3]\n list.range(-1, 1) == [-1, 0, 1]\n ```","url":"aiken/collection/list.html#range"},{"doc":"aiken/collection/list","title":"repeat","content":"repeat(elem: a, n_times: Int) -&gt; List&lt;a&gt;\n Construct a list filled with n copies of a value.\n\n ```aiken\n list.repeat(&quot;na&quot;, 3) == [&quot;na&quot;, &quot;na&quot;, &quot;na&quot;]\n ```","url":"aiken/collection/list.html#repeat"},{"doc":"aiken/collection/list","title":"all","content":"all(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Bool\n Determine if all elements of the list satisfy the given predicate.\n\n Note: an empty list always satisfies the predicate.\n\n ```aiken\n list.all([], fn(n) { n &gt; 0 }) == True\n list.all([1, 2, 3], fn(n) { n &gt; 0 }) == True\n list.all([1, 2, 3], fn(n) { n == 2 }) == False\n ```","url":"aiken/collection/list.html#all"},{"doc":"aiken/collection/list","title":"any","content":"any(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Bool\n Determine if at least one element of the list satisfies the given predicate.\n\n Note: an empty list never satisfies the predicate.\n\n ```aiken\n list.any([], fn(n) { n &gt; 2 }) == False\n list.any([1, 2, 3], fn(n) { n &gt; 0 }) == True\n list.any([1, 2, 3], fn(n) { n == 2 }) == True\n list.any([1, 2, 3], fn(n) { n &lt; 0 }) == False\n ```","url":"aiken/collection/list.html#any"},{"doc":"aiken/collection/list","title":"at","content":"at(self: List&lt;a&gt;, index: Int) -&gt; Option&lt;a&gt;\n Return Some(item) at the index or None if the index is out of range. The index is 0-based.\n\n ```aiken\n list.at([1, 2, 3], 1) == Some(2)\n list.at([1, 2, 3], 42) == None\n ```","url":"aiken/collection/list.html#at"},{"doc":"aiken/collection/list","title":"count","content":"count(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Int\n Count how many items in the list satisfy the given predicate.\n\n ```aiken\n list.count([], fn(a) { a &gt; 2}) == 0\n list.count([1, 2, 3], fn(a) { n &gt; 0 }) == 3\n list.count([1, 2, 3], fn(a) { n &gt;= 2 }) == 2\n list.count([1, 2, 3], fn(a) { n &gt; 5 }) == 0\n ```","url":"aiken/collection/list.html#count"},{"doc":"aiken/collection/list","title":"find","content":"find(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Option&lt;a&gt;\n Find the first element satisfying the given predicate, if any.\n\n ```aiken\n list.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)\n list.find([4, 5, 6], fn(x) { x == 2 }) == None\n ```","url":"aiken/collection/list.html#find"},{"doc":"aiken/collection/list","title":"has","content":"has(self: List&lt;a&gt;, elem: a) -&gt; Bool\n Figures out whether a list contain the given element.\n\n ```aiken\n list.has([1, 2, 3], 2) == True\n list.has([1, 2, 3], 14) == False\n list.has([], 14) == False\n ```","url":"aiken/collection/list.html#has"},{"doc":"aiken/collection/list","title":"head","content":"head(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Get the first element of a list\n\n ```aiken\n list.head([1, 2, 3]) == Some(1)\n list.head([]) == None\n ```","url":"aiken/collection/list.html#head"},{"doc":"aiken/collection/list","title":"is_empty","content":"is_empty(self: List&lt;a&gt;) -&gt; Bool\n Checks whether a list is empty.\n\n ```aiken\n list.is_empty([]) == True\n list.is_empty([1, 2, 3]) == False\n ```","url":"aiken/collection/list.html#is_empty"},{"doc":"aiken/collection/list","title":"index_of","content":"index_of(self: List&lt;a&gt;, elem: a) -&gt; Option&lt;Int&gt;\n Gets the index of an element of a list, if any. Otherwise, returns None.\n\n ```aiken\n list.index_of([1, 5, 2], 2) == Some(2)\n list.index_of([1, 7, 3], 4) == None\n list.index_of([1, 0, 9, 6], 6) == 3\n list.index_of([], 6) == None\n ```","url":"aiken/collection/list.html#index_of"},{"doc":"aiken/collection/list","title":"last","content":"last(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Get the last in the given list, if any.\n\n ```aiken\n list.last([]) == None\n list.last([1, 2, 3]) == Some(3)\n ```","url":"aiken/collection/list.html#last"},{"doc":"aiken/collection/list","title":"length","content":"length(self: List&lt;a&gt;) -&gt; Int\n Get the number of elements in the given list.\n\n ```aiken\n list.length([]) == 0\n list.length([1, 2, 3]) == 3\n ```","url":"aiken/collection/list.html#length"},{"doc":"aiken/collection/list","title":"delete","content":"delete(self: List&lt;a&gt;, elem: a) -&gt; List&lt;a&gt;\n Remove the first occurrence of the given element from the list.\n\n ```aiken\n list.delete([1, 2, 3, 1], 1) == [2, 3, 1]\n list.delete([1, 2, 3], 14) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#delete"},{"doc":"aiken/collection/list","title":"drop","content":"drop(self: List&lt;a&gt;, n: Int) -&gt; List&lt;a&gt;\n Drop the first `n` elements of a list.\n\n ```aiken\n list.drop([1, 2, 3], 2) == [3]\n list.drop([], 42) == []\n list.drop([1, 2, 3], 42) == []\n ```","url":"aiken/collection/list.html#drop"},{"doc":"aiken/collection/list","title":"drop_while","content":"drop_while(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Returns the suffix of the given list after removing all elements that satisfy the predicate.\n\n ```aiken\n list.drop_while([1, 2, 3], fn(x) { x &lt; 2 }) == [2, 3]\n list.drop_while([], fn(x) { x &gt; 2 }) == []\n list.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#drop_while"},{"doc":"aiken/collection/list","title":"filter","content":"filter(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Produce a list of elements that satisfy a predicate.\n\n ```aiken\n list.filter([1, 2, 3], fn(x) { x &gt;= 2 }) == [2, 3]\n list.filter([], fn(x) { x &gt; 2 }) == []\n list.filter([1, 2, 3], fn(x) { x == 3 }) == [3]\n ```","url":"aiken/collection/list.html#filter"},{"doc":"aiken/collection/list","title":"filter_map","content":"filter_map(self: List&lt;a&gt;, predicate: fn(a) -&gt; Option&lt;b&gt;) -&gt; List&lt;b&gt;\n Produce a list of transformed elements that satisfy a predicate.\n\n ```aiken\n let transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }\n list.filter_map([1, 2, 3], transform) == [3, 9]\n ```","url":"aiken/collection/list.html#filter_map"},{"doc":"aiken/collection/list","title":"init","content":"init(self: List&lt;a&gt;) -&gt; Option&lt;List&lt;a&gt;&gt;\n Return all elements except the last one.\n\n ```aiken\n list.init([]) == None\n list.init([1, 2, 3]) == Some([1, 2])\n ```","url":"aiken/collection/list.html#init"},{"doc":"aiken/collection/list","title":"partition","content":"partition(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; (List&lt;a&gt;, List&lt;a&gt;)\n Returns a tuple with all elements that satisfy the predicate at first\n element, and the rest as second element.\n\n ```aiken\n list.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n ```","url":"aiken/collection/list.html#partition"},{"doc":"aiken/collection/list","title":"slice","content":"slice(self: List&lt;a&gt;, from: Int, to: Int) -&gt; List&lt;a&gt;\n Extract a sublist from the given list using 0-based indexes. Negative\n indexes wrap over, so `-1` refers to the last element of the list.\n\n ```aiken\n list.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n list.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n list.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n ```","url":"aiken/collection/list.html#slice"},{"doc":"aiken/collection/list","title":"span","content":"span(self: List&lt;a&gt;, n: Int) -&gt; (List&lt;a&gt;, List&lt;a&gt;)\n Cut a list in two, such that the first list contains the given number of /\n elements and the second list contains the rest.\n\n Fundamentally equivalent to (but more efficient):\n\n ```aiken\n // span(xs, n) == (take(xs, n), drop(xs, n))\n span([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5])\n ```","url":"aiken/collection/list.html#span"},{"doc":"aiken/collection/list","title":"tail","content":"tail(self: List&lt;a&gt;) -&gt; Option&lt;List&lt;a&gt;&gt;\n Get elements of a list after the first one, if any.\n\n ```aiken\n list.tail([]) == None\n list.tail([1, 2, 3]) == Some([2, 3])\n ```","url":"aiken/collection/list.html#tail"},{"doc":"aiken/collection/list","title":"take","content":"take(self: List&lt;a&gt;, n: Int) -&gt; List&lt;a&gt;\n Get the first `n` elements of a list.\n\n ```aiken\n list.take([1, 2, 3], 2) == [1, 2]\n list.take([1, 2, 3], 14) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#take"},{"doc":"aiken/collection/list","title":"take_while","content":"take_while(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Returns the longest prefix of the given list where all elements satisfy the predicate.\n\n ```aiken\n list.take_while([1, 2, 3], fn(x) { x &gt; 2 }) == []\n list.take_while([1, 2, 3], fn(x) { x &lt; 2 }) == [1]\n ```","url":"aiken/collection/list.html#take_while"},{"doc":"aiken/collection/list","title":"unique","content":"unique(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Removes duplicate elements from a list.\n\n ```aiken\n list.unique([1, 2, 3, 1]) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#unique"},{"doc":"aiken/collection/list","title":"flat_map","content":"flat_map(self: List&lt;a&gt;, with: fn(a) -&gt; List&lt;b&gt;) -&gt; List&lt;b&gt;\n Map elements of a list into a new list and flatten the result.\n\n ```aiken\n list.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]\n ```","url":"aiken/collection/list.html#flat_map"},{"doc":"aiken/collection/list","title":"indexed_map","content":"indexed_map(self: List&lt;a&gt;, with: fn(Int, a) -&gt; result) -&gt; List&lt;result&gt;\n List [`map`](#map) but provides the position (0-based) of the elements while iterating.\n\n ```aiken\n list.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]\n ```","url":"aiken/collection/list.html#indexed_map"},{"doc":"aiken/collection/list","title":"map","content":"map(self: List&lt;a&gt;, with: fn(a) -&gt; result) -&gt; List&lt;result&gt;\n Apply a function to each element of a list.\n\n ```aiken\n list.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n ```","url":"aiken/collection/list.html#map"},{"doc":"aiken/collection/list","title":"map2","content":"map2(self: List&lt;a&gt;, bs: List&lt;b&gt;, with: fn(a, b) -&gt; result) -&gt; List&lt;result&gt;\n Apply a function of two arguments, combining elements from two lists.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n ```","url":"aiken/collection/list.html#map2"},{"doc":"aiken/collection/list","title":"map3","content":"map3(\n  self: List&lt;a&gt;,\n  bs: List&lt;b&gt;,\n  cs: List&lt;c&gt;,\n  with: fn(a, b, c) -&gt; result,\n) -&gt; List&lt;result&gt;\n Apply a function of three arguments, combining elements from three lists.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n ```","url":"aiken/collection/list.html#map3"},{"doc":"aiken/collection/list","title":"reverse","content":"reverse(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Return the list with its elements in the reserve order.\n\n ```aiken\n list.reverse([1, 2, 3]) == [3, 2, 1]\n ```","url":"aiken/collection/list.html#reverse"},{"doc":"aiken/collection/list","title":"sort","content":"sort(self: List&lt;a&gt;, compare: fn(a, a) -&gt; Ordering) -&gt; List&lt;a&gt;\n Sort a list in ascending order using the given comparison function.\n\n ```aiken\n use aiken/int\n\n sort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]\n sort([1, 2, 3], int.compare) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#sort"},{"doc":"aiken/collection/list","title":"unzip","content":"unzip(self: List&lt;(a, b)&gt;) -&gt; (List&lt;a&gt;, List&lt;b&gt;)\n Decompose a list of tuples into a tuple of lists.\n\n ```\n list.unzip([(1, &quot;a&quot;), (2, &quot;b&quot;)]) == ([1, 2], [&quot;a&quot;, &quot;b&quot;])\n ```","url":"aiken/collection/list.html#unzip"},{"doc":"aiken/collection/list","title":"concat","content":"concat(left: List&lt;a&gt;, right: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Merge two lists together.\n\n ```aiken\n list.concat([], []) == []\n list.concat([], [1, 2, 3]) == [1, 2, 3]\n list.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n ```","url":"aiken/collection/list.html#concat"},{"doc":"aiken/collection/list","title":"difference","content":"difference(self: List&lt;a&gt;, with: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Remove the first occurrence of each element of the second list from the first one.\n\n ```\n list.difference([&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;], [&quot;l&quot;, &quot;e&quot;, &quot;l&quot;]) == [&quot;h&quot;, &quot;o&quot;]\n list.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n list.difference([1, 2, 3], []) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#difference"},{"doc":"aiken/collection/list","title":"zip","content":"zip(self: List&lt;a&gt;, bs: List&lt;b&gt;) -&gt; List&lt;(a, b)&gt;\n Combine two lists together.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.zip([1, 2], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) == [(1, &quot;a&quot;), (2, &quot;b&quot;)]\n ```","url":"aiken/collection/list.html#zip"},{"doc":"aiken/collection/list","title":"foldl","content":"foldl(self: List&lt;a&gt;, zero: b, with: fn(a, b) -&gt; b) -&gt; b\n Reduce a list from left to right.\n\n ```aiken\n list.foldl([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n list.foldl([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]\n ```","url":"aiken/collection/list.html#foldl"},{"doc":"aiken/collection/list","title":"foldr","content":"foldr(self: List&lt;a&gt;, zero: b, with: fn(a, b) -&gt; b) -&gt; b\n Reduce a list from right to left.\n\n ```aiken\n list.foldr([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n list.foldr([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3]\n ```","url":"aiken/collection/list.html#foldr"},{"doc":"aiken/collection/list","title":"indexed_foldr","content":"indexed_foldr(\n  self: List&lt;a&gt;,\n  zero: result,\n  with: fn(Int, a, result) -&gt; result,\n) -&gt; result\n Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.\n\n ```aiken\n let group = fn(i, x, xs) { [(i, x), ..xs] }\n list.indexed_foldr([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [], group) == [\n   (0, &quot;a&quot;),\n   (1, &quot;b&quot;),\n   (2, &quot;c&quot;)\n ]\n ```","url":"aiken/collection/list.html#indexed_foldr"},{"doc":"aiken/collection/list","title":"reduce","content":"reduce(self: List&lt;a&gt;, zero: b, with: fn(b, a) -&gt; b) -&gt; b\n Reduce a list from left to right using the accumulator as left operand.\n Said differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n ```aiken\n list.reduce([#[1], #[2], #[3]], #[0], bytearray.concat) == #[0, 1, 2, 3]\n list.reduce([True, False, True], False, fn(b, a) { or { b, a } }) == True\n ```","url":"aiken/collection/list.html#reduce"},{"doc":"aiken/collection/list","title":"aiken/collection/list","content":"","url":"aiken/collection/list.html"},{"doc":"aiken/math/rational","title":"from_int","content":"from_int(numerator: Int) -&gt; Rational\n Create a new `Rational` from an `Int`.\n\n ```aiken\n Some(rational.from_int(14)) == rational.new(14, 1)\n Some(rational.from_int(-5)) == rational.new(-5, 1)\n Some(rational.from_int(0)) == rational.new(0, 1)\n ```","url":"aiken/math/rational.html#from_int"},{"doc":"aiken/math/rational","title":"new","content":"new(numerator: Int, denominator: Int) -&gt; Option&lt;Rational&gt;\n Make a `Rational` number from the ratio of two integers.\n\n Returns `None` when the denominator is null.\n\n ```aiken\n rational.new(14, 42) == Some(r)\n rational.new(14, 0) == None\n ```","url":"aiken/math/rational.html#new"},{"doc":"aiken/math/rational","title":"zero","content":"zero() -&gt; Rational\n A null `Rational`.","url":"aiken/math/rational.html#zero"},{"doc":"aiken/math/rational","title":"denominator","content":"denominator(self: Rational) -&gt; Int\n Get the denominator of a rational value.\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n rational.denominator(x) == 3\n ```","url":"aiken/math/rational.html#denominator"},{"doc":"aiken/math/rational","title":"numerator","content":"numerator(self: Rational) -&gt; Int\n Get the numerator of a rational value.\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n rational.numerator(x) == 2\n ```","url":"aiken/math/rational.html#numerator"},{"doc":"aiken/math/rational","title":"abs","content":"abs(self: Rational) -&gt; Rational\n Absolute value of a `Rational`.\n\n ```aiken\n expect Some(x) = rational.new(3, 2)\n expect Some(y) = rational.new(-3, 2)\n\n rational.abs(x) == x\n rational.abs(y) == x\n ```","url":"aiken/math/rational.html#abs"},{"doc":"aiken/math/rational","title":"negate","content":"negate(a: Rational) -&gt; Rational\n Change the sign of a `Rational`.\n\n ```aiken\n expect Some(x) = rational.new(3, 2)\n expect Some(y) = rational.new(-3, 2)\n\n rational.negate(x) == y\n rational.negate(y) == x\n ```","url":"aiken/math/rational.html#negate"},{"doc":"aiken/math/rational","title":"reciprocal","content":"reciprocal(self: Rational) -&gt; Option&lt;Rational&gt;\n Reciprocal of a `Rational` number. That is, a new `Rational` where the\n numerator and denominator have been swapped.\n\n ```aiken\n expect Some(x) = rational.new(2, 5)\n rational.reciprocal(x) == rational.new(5, 2)\n\n let y = rational.zero()\n rational.reciprocal(y) == None\n ```","url":"aiken/math/rational.html#reciprocal"},{"doc":"aiken/math/rational","title":"reduce","content":"reduce(self: Rational) -&gt; Rational\n Reduce a rational to its irreducible form. This operation makes the\n numerator and denominator coprime.\n\n ```aiken\n expect Some(x) = rational.new(80, 200)\n Some(rational.reduce(x)) == rational.new(2, 5)\n ```","url":"aiken/math/rational.html#reduce"},{"doc":"aiken/math/rational","title":"add","content":"add(left: Rational, right: Rational) -&gt; Rational\n Addition: sum of two rational values\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n expect Some(y) = rational.new(3, 4)\n\n Some(rational.add(x, y)) == rational.new(17, 12)\n ```","url":"aiken/math/rational.html#add"},{"doc":"aiken/math/rational","title":"div","content":"div(left: Rational, right: Rational) -&gt; Option&lt;Rational&gt;\n Division: quotient of two rational values. Returns `None` when the second\n value is null.\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n expect Some(y) = rational.new(3, 4)\n\n rational.div(x, y) == rational.new(8, 9)\n ```","url":"aiken/math/rational.html#div"},{"doc":"aiken/math/rational","title":"mul","content":"mul(left: Rational, right: Rational) -&gt; Rational\n Multiplication: the product of two rational values.\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n expect Some(y) = rational.new(3, 4)\n\n Some(rational.mul(x, y)) == rational.new(6, 12)\n ```","url":"aiken/math/rational.html#mul"},{"doc":"aiken/math/rational","title":"sub","content":"sub(left: Rational, right: Rational) -&gt; Rational\n Subtraction: difference of two rational values\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n expect Some(y) = rational.new(3, 4)\n\n Some(rational.sub(x, y)) == rational.new(-1, 12)\n ```","url":"aiken/math/rational.html#sub"},{"doc":"aiken/math/rational","title":"compare","content":"compare(left: Rational, right: Rational) -&gt; Ordering\n Compare two rationals for an ordering. This is safe to use even for\n non-reduced rationals.\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n expect Some(y) = rational.new(3, 4)\n expect Some(z) = rational.new(4, 6)\n\n compare(x, y) == Less\n compare(y, x) == Greater\n compare(x, x) == Equal\n compare(x, z) == Equal\n ```","url":"aiken/math/rational.html#compare"},{"doc":"aiken/math/rational","title":"compare_with","content":"compare_with(\n  left: Rational,\n  with: fn(Int, Int) -&gt; Bool,\n  right: Rational,\n) -&gt; Bool\n Comparison of two rational values using a chosen heuristic. For example:\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n expect Some(y) = rational.new(3, 4)\n\n rational.compare_with(x, &gt;, y) == False\n rational.compare_with(y, &gt;, x) == True\n rational.compare_with(x, &gt;, x) == False\n rational.compare_with(x, &gt;=, x) == True\n rational.compare_with(x, ==, x) == True\n rational.compare_with(x, ==, y) == False\n ```","url":"aiken/math/rational.html#compare_with"},{"doc":"aiken/math/rational","title":"arithmetic_mean","content":"arithmetic_mean(self: List&lt;Rational&gt;) -&gt; Option&lt;Rational&gt;\n Calculate the arithmetic mean between two `Rational` values.\n\n ```aiken\n let x = rational.from_int(0)\n let y = rational.from_int(1)\n let z = rational.from_int(2)\n\n expect Some(result) = rational.arithmetic_mean([x, y, z])\n\n rational.compare(result, y) == Equal\n ```","url":"aiken/math/rational.html#arithmetic_mean"},{"doc":"aiken/math/rational","title":"geometric_mean","content":"geometric_mean(left: Rational, right: Rational) -&gt; Option&lt;Rational&gt;\n Calculate the geometric mean between two `Rational` values. This returns\n either the exact result or the smallest integer nearest to the square root\n for the numerator and denominator.\n\n ```aiken\n expect Some(x) = rational.new(1, 3)\n expect Some(y) = rational.new(1, 6)\n\n rational.geometric_mean(x, y) == rational.new(1, 4)\n ```","url":"aiken/math/rational.html#geometric_mean"},{"doc":"aiken/math/rational","title":"ceil","content":"ceil(self: Rational) -&gt; Int\n Returns the smallest `Int` not less than a given `Rational`\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n rational.ceil(x) == 1\n\n expect Some(y) = rational.new(44, 14)\n rational.ceil(y) == 4\n\n expect Some(z) = rational.new(-14, 3)\n rational.ceil(z) == -4\n ```","url":"aiken/math/rational.html#ceil"},{"doc":"aiken/math/rational","title":"floor","content":"floor(self: Rational) -&gt; Int\n Returns the greatest `Int` no greater than a given `Rational`\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n rational.floor(x) == 0\n\n expect Some(y) = rational.new(44, 14)\n rational.floor(y) == 3\n\n expect Some(z) = rational.new(-14, 3)\n rational.floor(z) == -5\n ```","url":"aiken/math/rational.html#floor"},{"doc":"aiken/math/rational","title":"proper_fraction","content":"proper_fraction(self: Rational) -&gt; (Int, Rational)\n Returns the proper fraction of a given `Rational` `r`. That is, a 2-tuple of\n an `Int` and `Rational` (n, f) such that:\n\n - `r = n + f`;\n - `n` and `f` have the same sign as `r`;\n - `f` has an absolute value less than 1.","url":"aiken/math/rational.html#proper_fraction"},{"doc":"aiken/math/rational","title":"round","content":"round(self: Rational) -&gt; Int\n Round the argument to the nearest whole number. If the argument is\n equidistant between two values, the greater value is returned (it\n rounds half towards positive infinity).\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n rational.round(x) == 1\n\n expect Some(y) = rational.new(3, 2)\n rational.round(y) == 2\n\n expect Some(z) = rational.new(-3, 2)\n rational.round(z) == -1\n ```\n\n &gt; [!CAUTION]\n &gt; This behaves differently than _Haskell_. If you&#39;re coming from `PlutusTx`, beware that in Haskell, rounding on equidistant values depends on the whole number being odd or even.\n &gt; If you need this behaviour, use [`round_even`](#round_even).","url":"aiken/math/rational.html#round"},{"doc":"aiken/math/rational","title":"round_even","content":"round_even(self: Rational) -&gt; Int\n Round the argument to the nearest whole number. If the argument is\n equidistant between two values, it returns the value that is even (it\n rounds half to even, also known as &#39;banker&#39;s rounding&#39;).\n\n ```aiken\n expect Some(w) = rational.new(2, 3)\n rational.round_even(w) == 1\n\n expect Some(x) = rational.new(3, 2)\n rational.round_even(x) == 2\n\n expect Some(y) = rational.new(5, 2)\n rational.round_even(y) == 2\n\n expect Some(y) = rational.new(-3, 2)\n rational.round_even(y) == -2\n ```","url":"aiken/math/rational.html#round_even"},{"doc":"aiken/math/rational","title":"truncate","content":"truncate(self: Rational) -&gt; Int\n Returns the nearest `Int` between zero and a given `Rational`.\n\n ```aiken\n expect Some(x) = rational.new(2, 3)\n rational.truncate(x) == 0\n\n expect Some(y) = rational.new(44, 14)\n rational.truncate(y) == 3\n\n expect Some(z) = rational.new(-14, 3)\n rational.truncate(z) == -4\n ```","url":"aiken/math/rational.html#truncate"},{"doc":"aiken/math/rational","title":"Rational","content":"Rational\n Opaque type used to ensure the sign of the Rational is managed strictly in the numerator.\n","url":"aiken/math/rational.html#Rational"},{"doc":"aiken/math/rational","title":"aiken/math/rational","content":" This module implements operations between rational numbers.\n\n &gt; [!CAUTION] Internally, rational aren&#39;t automatically reduced as this is **only done on-demand**.\n &gt;\n &gt; Thus, for example:\n &gt;\n &gt; ```aiken\n &gt; rational.new(2, 3) != rational.new(4, 6)\n &gt; ```\n &gt;\n &gt; Comparing rational values should, therefore, only happen after reduction (see [reduce](#reduce)) or via the [compare](#compare) method.","url":"aiken/math/rational.html"},{"doc":"cardano/certificate","title":"Certificate","content":"Certificate {\n  RegisterCredential { credential: Credential, deposit: Never }\n  UnregisterCredential { credential: Credential, refund: Never }\n  DelegateCredential { credential: Credential, delegate: Delegate }\n  RegisterAndDelegateCredential { credential: Credential, delegate: Delegate, deposit: Lovelace }\n  RegisterDelegateRepresentative { delegate_representative: Credential, deposit: Lovelace }\n  UpdateDelegateRepresentative { delegate_representative: Credential }\n  UnregisterDelegateRepresentative { delegate_representative: Credential, refund: Lovelace }\n  RegisterStakePool { stake_pool: StakePoolId, vrf: VerificationKeyHash }\n  RetireStakePool { stake_pool: StakePoolId, at_epoch: Int }\n  AuthorizeConstitutionalCommitteeProxy { constitutional_committee_member: Credential, proxy: Credential }\n  RetireFromConstitutionalCommittee { constitutional_committee_member: Credential }\n}\n An on-chain certificate attesting of some operation. Publishing\n certificates triggers different kind of rules; most of the time,\n they require signatures from specific keys.\nRegisterCredential { credential: Credential, deposit: Never }\n Register a stake credential with an optional deposit amount.\n The deposit is always present when using the new registration certificate\n format available since the Conway era.\nUnregisterCredential { credential: Credential, refund: Never }\n Un-Register a stake credential with an optional refund amount\n The deposit is always present when using the new de-registration certificate\n format available since the Conway era.\nDelegateCredential { credential: Credential, delegate: Delegate }\n Delegate stake to a [Delegate](#Delegate).\nRegisterAndDelegateCredential {\n  credential: Credential,\n  delegate: Delegate,\n  deposit: Lovelace,\n}\n Register and delegate staking credential to a Delegatee in one certificate.\nRegisterDelegateRepresentative {\n  delegate_representative: Credential,\n  deposit: Lovelace,\n}\n Register a delegate representative (a.k.a DRep). The deposit is explicit and\n is refunded when the delegate steps down (unregister).\nUpdateDelegateRepresentative { delegate_representative: Credential }\n Update a delegate representative (a.k.a DRep). The certificate also contains\n metadata which aren&#39;t visible on-chain.\nUnregisterDelegateRepresentative {\n  delegate_representative: Credential,\n  refund: Lovelace,\n}\n UnRegister a delegate representative, and refund back its past deposit.\nRegisterStakePool { stake_pool: StakePoolId, vrf: VerificationKeyHash }\n Register a new stake pool\nRetireStakePool { stake_pool: StakePoolId, at_epoch: Int }\n Retire a stake pool. &#39;at_epoch&#39; indicates in which the retirement will take place\nAuthorizeConstitutionalCommitteeProxy {\n  constitutional_committee_member: Credential,\n  proxy: Credential,\n}\n Authorize a Hot credential for a specific Committee member&#39;s cold credential\nRetireFromConstitutionalCommittee {\n  constitutional_committee_member: Credential,\n}\n Step down from the constitutional committee as a member.","url":"cardano/certificate.html#Certificate"},{"doc":"cardano/certificate","title":"Delegate","content":"Delegate {\n  DelegateBlockProduction { stake_pool: StakePoolId }\n  DelegateVote { delegate_representative: DelegateRepresentative }\n  DelegateBoth { stake_pool: StakePoolId, delegate_representative: DelegateRepresentative }\n}\n A type of stake delegation that can be either block-production, vote or\n both. Note that delegation types aren&#39;t cancelling one another, so it is\n possible to delegate block production in one transaction, and delegate vote\n in another. This second delegation **does NOT** invalidate the first one.\nDelegateBlockProduction { stake_pool: StakePoolId }\n\nDelegateVote { delegate_representative: DelegateRepresentative }\n\nDelegateBoth {\n  stake_pool: StakePoolId,\n  delegate_representative: DelegateRepresentative,\n}\n","url":"cardano/certificate.html#Delegate"},{"doc":"cardano/certificate","title":"DelegateRepresentative","content":"DelegateRepresentative {\n  Registered(Credential)\n  AlwaysAbstain\n  AlwaysNoConfidence\n}\n\nRegistered(Credential)\n\nAlwaysAbstain\n\nAlwaysNoConfidence\n","url":"cardano/certificate.html#DelegateRepresentative"},{"doc":"cardano/certificate","title":"StakePoolId","content":"StakePoolId = Hash&lt;Blake2b_224, VerificationKey&gt;\n\n","url":"cardano/certificate.html#StakePoolId"},{"doc":"cardano/certificate","title":"cardano/certificate","content":"","url":"cardano/certificate.html"},{"doc":"aiken/option","title":"is_none","content":"is_none(self: Option&lt;a&gt;) -&gt; Bool\n Asserts whether an option is `None`.","url":"aiken/option.html#is_none"},{"doc":"aiken/option","title":"is_some","content":"is_some(self: Option&lt;a&gt;) -&gt; Bool\n Asserts whether an option is `Some`, irrespective of the value it contains.","url":"aiken/option.html#is_some"},{"doc":"aiken/option","title":"and_then","content":"and_then(self: Option&lt;a&gt;, then: fn(a) -&gt; Option&lt;result&gt;) -&gt; Option&lt;result&gt;\n Chain together many computations that may fail.\n\n ```aiken\n self\n   |&gt; dict.get(policy_id)\n   |&gt; option.and_then(dict.get(_, asset_name))\n   |&gt; option.or_else(0)\n ```","url":"aiken/option.html#and_then"},{"doc":"aiken/option","title":"choice","content":"choice(self: List&lt;Option&lt;a&gt;&gt;) -&gt; Option&lt;a&gt;\n Picks the first element which is not None. If there&#39;s no such element, return None.\n\n ```aiken\n option.choice([]) == None\n option.choice([Some(14), Some(42)]) == Some(14)\n option.choice([None, Some(42)]) == Some(42)\n option.choice([None, None]) == None\n ```","url":"aiken/option.html#choice"},{"doc":"aiken/option","title":"flatten","content":"flatten(opt: Option&lt;Option&lt;a&gt;&gt;) -&gt; Option&lt;a&gt;\n Converts from `Option&lt;Option&lt;a&gt;&gt;` to `Option&lt;a&gt;`.\n\n ```aiken\n option.flatten(Some(Some(42))) == Some(42)\n option.flatten(Some(None)) == None\n option.flatten(None) == None\n ```\n\n Flattening only removes one level of nesting at a time:\n\n ```aiken\n flatten(Some(Some(Some(42)))) == Some(Some(42))\n Some(Some(Some(42))) |&gt; flatten |&gt; flatten == Some(42)\n ```","url":"aiken/option.html#flatten"},{"doc":"aiken/option","title":"map","content":"map(self: Option&lt;a&gt;, with: fn(a) -&gt; result) -&gt; Option&lt;result&gt;\n Apply a function to the inner value of an [`Option`](#option)\n\n ```aiken\n option.map(None, fn(n) { n * 2 }) == None\n option.map(Some(14), fn(n) { n * 2 }) == Some(28)\n ```","url":"aiken/option.html#map"},{"doc":"aiken/option","title":"map2","content":"map2(\n  opt_a: Option&lt;a&gt;,\n  opt_b: Option&lt;b&gt;,\n  with: fn(a, b) -&gt; result,\n) -&gt; Option&lt;result&gt;\n Combine two [`Option`](#option) together.\n\n ```aiken\n type Foo {\n   Foo(Int, Int)\n }\n\n option.map2(Some(14), Some(42), Foo) == Some(Foo(14, 42))\n option.map2(None, Some(42), Foo) == None\n option.map2(Some(14), None, Foo) == None\n ```","url":"aiken/option.html#map2"},{"doc":"aiken/option","title":"map3","content":"map3(\n  opt_a: Option&lt;a&gt;,\n  opt_b: Option&lt;b&gt;,\n  opt_c: Option&lt;c&gt;,\n  with: fn(a, b, c) -&gt; result,\n) -&gt; Option&lt;result&gt;\n Combine three [`Option`](#option) together.\n\n ```aiken\n type Foo {\n   Foo(Int, Int, Int)\n }\n\n option.map3(Some(14), Some(42), Some(1337), Foo) == Some(Foo(14, 42, 1337))\n option.map3(None, Some(42), Some(1337), Foo) == None\n option.map3(Some(14), None, None, Foo) == None\n ```","url":"aiken/option.html#map3"},{"doc":"aiken/option","title":"or_try","content":"or_try(self: Option&lt;a&gt;, compute_default: fn() -&gt; Option&lt;a&gt;) -&gt; Option&lt;a&gt;\n Like [`or_else`](#or_else) but allows returning an `Option`.\n This is effectively mapping the error branch.\n\n ```aiken\n option.or_try(None, fn(_) { Some(&quot;aiken&quot;) }) == Some(&quot;aiken&quot;)\n option.or_try(Some(42), fn(_) { Some(14) }) == Some(42)\n option.or_try(None, fn (_) { fail }) =&gt; 💥\n ```","url":"aiken/option.html#or_try"},{"doc":"aiken/option","title":"or_else","content":"or_else(self: Option&lt;a&gt;, default: a) -&gt; a\n Provide a default value, turning an optional value into a normal value.\n\n ```aiken\n option.or_else(None, &quot;aiken&quot;) == &quot;aiken&quot;\n option.or_else(Some(42), 14) == 42\n ```","url":"aiken/option.html#or_else"},{"doc":"aiken/option","title":"aiken/option","content":" A type to capture optional results; useful for handling errors.\n\n Note that the `Option` type and its constructors are readily available in Aiken. They are part of the [Prelude](https://aiken-lang.github.io/prelude/aiken.html#Option) module imported by default in every module.","url":"aiken/option.html"},{"doc":"cardano/transaction","title":"find_input","content":"find_input(\n  inputs: List&lt;Input&gt;,\n  output_reference: OutputReference,\n) -&gt; Option&lt;Input&gt;\n Find an input by its [`OutputReference`](#OutputReference). This is typically used in\n combination with the `Spend` [`ScriptPurpose`](#ScriptPurpose) to find a script&#39;s own\n input.\n\n ```aiken\n validator {\n   spend(datum, redeemer, my_output_reference, self) {\n     expect Some(input) =\n       self.inputs\n         |&gt; transaction.find_input(my_output_reference)\n   }\n }\n ```","url":"cardano/transaction.html#find_input"},{"doc":"cardano/transaction","title":"find_datum","content":"find_datum(\n  outputs: List&lt;Output&gt;,\n  datums: Dict&lt;DataHash, Data&gt;,\n  datum_hash: DataHash,\n) -&gt; Option&lt;Data&gt;\n Find a [`Datum`](#Datum) by its hash, if present. The function looks first for\n datums in the witness set, and then for inline datums if it doesn&#39;t find any in\n witnesses.","url":"cardano/transaction.html#find_datum"},{"doc":"cardano/transaction","title":"find_script_outputs","content":"find_script_outputs(\n  outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n) -&gt; List&lt;Output&gt;\n Find all outputs that are paying into the given script hash, if any. This is useful for\n contracts running over multiple transactions.","url":"cardano/transaction.html#find_script_outputs"},{"doc":"cardano/transaction","title":"placeholder","content":"placeholder() -&gt; Transaction\n A placeholder / empty `Transaction` to serve as a base in a transaction\n builder. This is particularly useful for constructing test transactions.\n\n Every field is empty or null, and we have in particular:\n\n ```aiken\n use aiken/interval\n\n transaction.placeholder().id ==\n   #&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;\n\n transaction.placeholder().validity_range == interval.everything()\n ```","url":"cardano/transaction.html#placeholder"},{"doc":"cardano/transaction","title":"Datum","content":"Datum {\n  NoDatum\n  DatumHash(DataHash)\n  InlineDatum(Data)\n}\n An output `Datum`.\nNoDatum\n\nDatumHash(DataHash)\n A datum referenced by its hash digest.\nInlineDatum(Data)\n A datum completely inlined in the output.","url":"cardano/transaction.html#Datum"},{"doc":"cardano/transaction","title":"Input","content":"Input {\n  output_reference: OutputReference,\n  output: Output,\n}\n An `Input` made of an output reference and, the resolved value associated with that output.\nInput { output_reference: OutputReference, output: Output }\n","url":"cardano/transaction.html#Input"},{"doc":"cardano/transaction","title":"Output","content":"Output {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option&lt;ScriptHash&gt;,\n}\n A transaction `Output`, with an address, a value and optional datums and script references.\nOutput {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option&lt;ScriptHash&gt;,\n}\n","url":"cardano/transaction.html#Output"},{"doc":"cardano/transaction","title":"OutputReference","content":"OutputReference {\n  transaction_id: Hash&lt;Blake2b_256, Transaction&gt;,\n  output_index: Int,\n}\n An `OutputReference` is a unique reference to an output on-chain. The `output_index`\n corresponds to the position in the output list of the transaction (identified by its id)\n that produced that output\nOutputReference {\n  transaction_id: Hash&lt;Blake2b_256, Transaction&gt;,\n  output_index: Int,\n}\n","url":"cardano/transaction.html#OutputReference"},{"doc":"cardano/transaction","title":"Redeemer","content":"Redeemer = Data\n A type-alias for Redeemers, passed to scripts for validation. The `Data` is\n opaque because it is user-defined and it is the script&#39;s responsibility to\n parse it into its expected form.\n","url":"cardano/transaction.html#Redeemer"},{"doc":"cardano/transaction","title":"ScriptPurpose","content":"ScriptPurpose {\n  Mint(PolicyId)\n  Spend(OutputReference)\n  Withdraw(Credential)\n  Publish { at: Index, certificate: Certificate }\n  Vote(Voter)\n  Propose { at: Index, proposal_procedure: ProposalProcedure }\n}\n Characterizes the script purpose.\nMint(PolicyId)\n For scripts executed as minting/burning policies, to insert\n or remove assets from circulation. It&#39;s parameterized by the identifier\n of the associated policy.\nSpend(OutputReference)\n For scripts that are used as payment credentials for addresses in\n transaction outputs. They govern the rule by which the output they\n reference can be spent.\nWithdraw(Credential)\n For scripts that validate reward withdrawals from a reward account.\n\n The argument identifies the target reward account.\nPublish { at: Index, certificate: Certificate }\n Needed when delegating to a pool using stake credentials defined as a\n custom script. This purpose is also triggered when de-registering such\n stake credentials.\n\n The Int is a 0-based index of the given `Certificate` in `certificates`.\nVote(Voter)\n Voting for a type of voter using a governance action id to vote\n yes / no / abstain inside a transaction.\n\n The voter is who is doing the governance action.\nPropose { at: Index, proposal_procedure: ProposalProcedure }\n Used to propose a governance action.\n\n A 0-based index of the given `ProposalProcedure` in `proposal_procedures`.","url":"cardano/transaction.html#ScriptPurpose"},{"doc":"cardano/transaction","title":"Transaction","content":"Transaction {\n  inputs: List&lt;Input&gt;,\n  reference_inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  fee: Lovelace,\n  mint: Value,\n  certificates: List&lt;Certificate&gt;,\n  withdrawals: Pairs&lt;Credential, Lovelace&gt;,\n  validity_range: ValidityRange,\n  extra_signatories: List&lt;VerificationKeyHash&gt;,\n  redeemers: Pairs&lt;ScriptPurpose, Redeemer&gt;,\n  datums: Dict&lt;DataHash, Data&gt;,\n  id: TransactionId,\n  votes: Pairs&lt;Voter, Pairs&lt;GovernanceActionId, Vote&gt;&gt;,\n  proposal_procedures: List&lt;ProposalProcedure&gt;,\n  current_treasury_amount: Option&lt;Lovelace&gt;,\n  treasury_donation: Option&lt;Lovelace&gt;,\n}\n A Cardano `Transaction`, as seen by on-chain scripts.\n\n Note that this is a representation of a transaction, and not the 1:1\n translation of the transaction as seen by the ledger. In particular,\n on-chain scripts can&#39;t see inputs locked by bootstrap addresses, outputs\n to bootstrap addresses or just transaction metadata.\nTransaction {\n  inputs: List&lt;Input&gt;,\n  reference_inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  fee: Lovelace,\n  mint: Value,\n  certificates: List&lt;Certificate&gt;,\n  withdrawals: Pairs&lt;Credential, Lovelace&gt;,\n  validity_range: ValidityRange,\n  extra_signatories: List&lt;VerificationKeyHash&gt;,\n  redeemers: Pairs&lt;ScriptPurpose, Redeemer&gt;,\n  datums: Dict&lt;DataHash, Data&gt;,\n  id: TransactionId,\n  votes: Pairs&lt;Voter, Pairs&lt;GovernanceActionId, Vote&gt;&gt;,\n  proposal_procedures: List&lt;ProposalProcedure&gt;,\n  current_treasury_amount: Option&lt;Lovelace&gt;,\n  treasury_donation: Option&lt;Lovelace&gt;,\n}\n","url":"cardano/transaction.html#Transaction"},{"doc":"cardano/transaction","title":"TransactionId","content":"TransactionId = Hash&lt;Blake2b_256, Transaction&gt;\n\n","url":"cardano/transaction.html#TransactionId"},{"doc":"cardano/transaction","title":"ValidityRange","content":"ValidityRange = Interval&lt;Int&gt;\n An interval of POSIX time, measured in **number of milliseconds** since 1970-01-01T00:00:00Z.\n","url":"cardano/transaction.html#ValidityRange"},{"doc":"cardano/transaction","title":"cardano/transaction","content":"","url":"cardano/transaction.html"},{"doc":"aiken/collection/pairs","title":"get_all","content":"get_all(self: Pairs&lt;key, value&gt;, key: key) -&gt; List&lt;value&gt;\n Get all values in the alist associated with a given key.\n\n ```aiken\n pairs.get_all([], &quot;a&quot;) == []\n pairs.get_all([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == [1]\n pairs.get_all([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == [1]\n pairs.get_all([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == [1, 3]\n ```","url":"aiken/collection/pairs.html#get_all"},{"doc":"aiken/collection/pairs","title":"get_first","content":"get_first(self: Pairs&lt;key, value&gt;, key: key) -&gt; Option&lt;value&gt;\n Get the value in the alist by its key.\n If multiple values with the same key exist, only the first one is returned.\n\n ```aiken\n pairs.get_first([], &quot;a&quot;) == None\n pairs.get_first([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == Some(1)\n pairs.get_first([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == Some(1)\n pairs.get_first([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == Some(1)\n ```","url":"aiken/collection/pairs.html#get_first"},{"doc":"aiken/collection/pairs","title":"get_last","content":"get_last(self: Pairs&lt;key, value&gt;, key: key) -&gt; Option&lt;value&gt;\n Get the value in the alist by its key.\n If multiple values with the same key exist, only the last one is returned.\n\n ```aiken\n pairs.get_last([], &quot;a&quot;) == None\n pairs.get_last([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == Some(1)\n pairs.get_last([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == Some(1)\n pairs.get_last([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == Some(3)\n ```","url":"aiken/collection/pairs.html#get_last"},{"doc":"aiken/collection/pairs","title":"find_all","content":"find_all(self: Pairs&lt;key, value&gt;, v: value) -&gt; List&lt;key&gt;\n Finds all keys in the alist associated with a given value.\n\n ```aiken\n pairs.find_all([], 1) == []\n pairs.find_all([Pair(&quot;a&quot;, 1)], 1) == [&quot;a&quot;]\n pairs.find_all([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], 1) == [&quot;a&quot;]\n pairs.find_all([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;c&quot;, 1)], 1) == [&quot;a&quot;, &quot;c&quot;]\n ```","url":"aiken/collection/pairs.html#find_all"},{"doc":"aiken/collection/pairs","title":"find_first","content":"find_first(self: Pairs&lt;key, value&gt;, v: value) -&gt; Option&lt;key&gt;\n Finds the first key in the alist associated with a given value, if any.\n\n ```aiken\n pairs.find_first([], 1) == None\n pairs.find_first([Pair(&quot;a&quot;, 1)], 1) == Some(&quot;a&quot;)\n pairs.find_first([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], 1) == Some(&quot;a&quot;)\n pairs.find_first([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;c&quot;, 1)], 1) == Some(&quot;a&quot;)\n ```","url":"aiken/collection/pairs.html#find_first"},{"doc":"aiken/collection/pairs","title":"find_last","content":"find_last(self: Pairs&lt;key, value&gt;, v: value) -&gt; Option&lt;key&gt;\n Finds the last key in the alist associated with a given value, if any.\n\n ```aiken\n pairs.find_last([], 1) == None\n pairs.find_last([Pair(&quot;a&quot;, 1)], 1) == Some(&quot;a&quot;)\n pairs.find_last([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], 1) == Some(&quot;a&quot;)\n pairs.find_last([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;c&quot;, 1)], 1) == Some(&quot;c&quot;)\n ```","url":"aiken/collection/pairs.html#find_last"},{"doc":"aiken/collection/pairs","title":"has_key","content":"has_key(self: Pairs&lt;key, value&gt;, k: key) -&gt; Bool\n Check if a key exists in the pairs.\n\n ```aiken\n pairs.has_key([], &quot;a&quot;) == False\n pairs.has_key([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == True\n pairs.has_key([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == True\n pairs.has_key([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == True\n ```","url":"aiken/collection/pairs.html#has_key"},{"doc":"aiken/collection/pairs","title":"keys","content":"keys(self: Pairs&lt;key, value&gt;) -&gt; List&lt;key&gt;\n Extract all the keys present in a given `Pairs`.\n\n ```aiken\n pairs.keys([]) == []\n pairs.keys([Pair(&quot;a&quot;, 1)]) == [&quot;a&quot;]\n pairs.keys([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)]) == [&quot;a&quot;, &quot;b&quot;]\n pairs.keys([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)]) == [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;]\n ```","url":"aiken/collection/pairs.html#keys"},{"doc":"aiken/collection/pairs","title":"values","content":"values(self: Pairs&lt;key, value&gt;) -&gt; List&lt;value&gt;\n Extract all the values present in a given `Pairs`.\n\n ```aiken\n pairs.values([]) == []\n pairs.values([Pair(&quot;a&quot;, 1)]) == [1]\n pairs.values([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)]) == [1, 2]\n pairs.values([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)]) == [1, 2, 3]\n ```","url":"aiken/collection/pairs.html#values"},{"doc":"aiken/collection/pairs","title":"delete_all","content":"delete_all(self: Pairs&lt;key, value&gt;, key: key) -&gt; Pairs&lt;key, value&gt;\n Remove all key-value pairs matching the key from the Pairs. If the key is not found, no changes are made.\n\n ```aiken\n pairs.delete_all([], &quot;a&quot;) == []\n pairs.delete_all([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == []\n pairs.delete_all([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == [Pair(&quot;b&quot;, 2)]\n pairs.delete_all([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == [Pair(&quot;b&quot;, 2)]\n ```","url":"aiken/collection/pairs.html#delete_all"},{"doc":"aiken/collection/pairs","title":"delete_first","content":"delete_first(self: Pairs&lt;key, value&gt;, key: key) -&gt; Pairs&lt;key, value&gt;\n Remove a single key-value pair from the `Pairs`. If the key is not found, no changes are made.\n Duplicate keys are not deleted. Only the **first** key found is deleted.\n\n ```aiken\n pairs.delete_first([], &quot;a&quot;) == []\n pairs.delete_first([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == []\n pairs.delete_first([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == [Pair(&quot;b&quot;, 2)]\n pairs.delete_first([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == [Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)]\n ```","url":"aiken/collection/pairs.html#delete_first"},{"doc":"aiken/collection/pairs","title":"delete_last","content":"delete_last(self: Pairs&lt;key, value&gt;, key: key) -&gt; Pairs&lt;key, value&gt;\n Remove a single key-value pair from the Pairs. If the key is not found, no changes are made.\n Duplicate keys are not deleted. Only the **last** key found is deleted.\n\n ```aiken\n pairs.delete_last([], &quot;a&quot;) == []\n pairs.delete_last([Pair(&quot;a&quot;, 1)], &quot;a&quot;) == []\n pairs.delete_last([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)], &quot;a&quot;) == [Pair(&quot;b&quot;, 2)]\n pairs.delete_last([Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2), Pair(&quot;a&quot;, 3)], &quot;a&quot;) == [Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2)]\n ```","url":"aiken/collection/pairs.html#delete_last"},{"doc":"aiken/collection/pairs","title":"map","content":"map(\n  self: Pairs&lt;key, value&gt;,\n  with: fn(key, value) -&gt; result,\n) -&gt; Pairs&lt;key, result&gt;\n Apply a function to all key-value pairs in a alist, replacing the values.\n\n ```aiken\n let fixture = [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200)]\n\n pairs.map(fixture, fn(_k, v) { v * 2 }) == [Pair(&quot;a&quot;, 200), Pair(&quot;b&quot;, 400)]\n ```","url":"aiken/collection/pairs.html#map"},{"doc":"aiken/collection/pairs","title":"foldl","content":"foldl(\n  self: Pairs&lt;key, value&gt;,\n  zero: result,\n  with: fn(key, value, result) -&gt; result,\n) -&gt; result\n Fold over the key-value pairs in a pairs. The fold direction follows keys\n in ascending order and is done from left-to-right.\n\n ```aiken\n let fixture = [\n   Pair(1, 100),\n   Pair(2, 200),\n   Pair(3, 300),\n ]\n\n pairs.foldl(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n ```","url":"aiken/collection/pairs.html#foldl"},{"doc":"aiken/collection/pairs","title":"foldr","content":"foldr(\n  self: Pairs&lt;key, value&gt;,\n  zero: result,\n  with: fn(key, value, result) -&gt; result,\n) -&gt; result\n Fold over the key-value pairs in a Pairs. The fold direction follows the\n order of elements in the Pairs and is done from right-to-left.\n\n ```aiken\n let fixture = [\n   Pair(1, 100),\n   Pair(2, 200),\n   Pair(3, 300),\n ]\n\n pairs.foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n ```","url":"aiken/collection/pairs.html#foldr"},{"doc":"aiken/collection/pairs","title":"aiken/collection/pairs","content":" A module for working with associative lists (a.k.a `Pairs`).\n\n While any function that works on `List` also work on `Pairs`, this module provides some extra helpers\n that are specifically tailored to working with associative lists. Fundamentally, a `Pairs&lt;k, v&gt;` is\n a type-alias to `List&lt;Pair&lt;k, v&gt;&gt;`.\n\n &gt; [!CAUTION]\n &gt;\n &gt; Unlike dictionnaries (a.k.a. [`Dict`](./dict.html#Dict), associative lists make no assumption\n &gt; about the ordering of elements within the list. As a result, lookup\n &gt; functions do traverse the entire list when invoked. They are also not _sets_,\n &gt; and thus allow for duplicate keys. This is reflected in the functions used\n &gt; to interact with them.","url":"aiken/collection/pairs.html"},{"doc":"cardano/address","title":"from_script","content":"from_script(script: Hash&lt;Blake2b_224, Script&gt;) -&gt; Address\n Smart-constructor for an [Address](#Address) from a [script](#Script) hash. The address has no delegation rights whatsoever.","url":"cardano/address.html#from_script"},{"doc":"cardano/address","title":"from_verification_key","content":"from_verification_key(vk: Hash&lt;Blake2b_224, VerificationKey&gt;) -&gt; Address\n Smart-constructor for an [Address](#Address) from a [verification key](#VerificationKey) hash. The resulting address has no delegation rights whatsoever.","url":"cardano/address.html#from_verification_key"},{"doc":"cardano/address","title":"with_delegation_key","content":"with_delegation_key(\n  self: Address,\n  vk: Hash&lt;Blake2b_224, VerificationKey&gt;,\n) -&gt; Address\n Set (or reset) the delegation part of an [Address](#Address) using a [verification key](#VerificationKey) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).","url":"cardano/address.html#with_delegation_key"},{"doc":"cardano/address","title":"with_delegation_script","content":"with_delegation_script(\n  self: Address,\n  script: Hash&lt;Blake2b_224, Script&gt;,\n) -&gt; Address\n Set (or reset) the delegation part of an [Address](#Address) using a [script](#Script) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).","url":"cardano/address.html#with_delegation_script"},{"doc":"cardano/address","title":"Address","content":"Address {\n  payment_credential: PaymentCredential,\n  stake_credential: Option&lt;StakeCredential&gt;,\n}\n A Cardano `Address` typically holding one or two credential references.\n\n Note that legacy bootstrap addresses (a.k.a. &#39;Byron addresses&#39;) are\n completely excluded from Plutus contexts. Thus, from an on-chain\n perspective only exists addresses of type 00, 01, ..., 07 as detailed\n in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).\nAddress {\n  payment_credential: PaymentCredential,\n  stake_credential: Option&lt;StakeCredential&gt;,\n}\n","url":"cardano/address.html#Address"},{"doc":"cardano/address","title":"Credential","content":"Credential {\n  VerificationKey(VerificationKeyHash)\n  Script(ScriptHash)\n}\n A general structure for representing an on-chain `Credential`.\n\n Credentials are always one of two kinds: a direct public/private key\n pair, or a script (native or Plutus).\nVerificationKey(VerificationKeyHash)\n\nScript(ScriptHash)\n","url":"cardano/address.html#Credential"},{"doc":"cardano/address","title":"PaymentCredential","content":"PaymentCredential = Credential\n A &#39;PaymentCredential&#39; represents the spending conditions associated with\n some output. Hence,\n\n - a `VerificationKeyCredential` captures an output locked by a public/private key pair;\n - and a `ScriptCredential` captures an output locked by a native or Plutus script.\n\n","url":"cardano/address.html#PaymentCredential"},{"doc":"cardano/address","title":"Referenced","content":"Referenced&lt;a&gt; {\n  Inline(a)\n  Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n}\n Represent a type of object that can be represented either inline (by hash)\n or via a reference (i.e. a pointer to an on-chain location).\n\n This is mainly use for capturing pointers to a stake credential\n registration certificate in the case of so-called pointer addresses.\nInline(a)\n\nPointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n","url":"cardano/address.html#Referenced"},{"doc":"cardano/address","title":"StakeCredential","content":"StakeCredential = Referenced&lt;Credential&gt;\n A `StakeCredential` represents the delegation and rewards withdrawal conditions\n associated with some stake address / account.\n\n A `StakeCredential` is either provided inline, or, by reference using an\n on-chain pointer.\n\n Read more about pointers in [CIP-0019 :: Pointers](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#pointers).\n","url":"cardano/address.html#StakeCredential"},{"doc":"cardano/address","title":"cardano/address","content":"","url":"cardano/address.html"},{"doc":"aiken/collection/dict","title":"new","content":"new() -&gt; Dict&lt;key, value&gt;\n Create a new empty Dict\n ```aiken\n dict.to_pairs(dict.new()) == []\n ```","url":"aiken/collection/dict.html#new"},{"doc":"aiken/collection/dict","title":"from_ascending_pairs","content":"from_ascending_pairs(xs: Pairs&lt;ByteArray, value&gt;) -&gt; Dict&lt;key, value&gt;\n Like [&#39;from_pairs&#39;](#from_pairs), but from an already sorted list by ascending\n keys. This function fails (i.e. halt the program execution) if the list isn&#39;t\n sorted.\n\n ```aiken\n let pairs = [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n\n let result =\n   dict.from_ascending_pairs(pairs)\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n ```\n\n This is meant to be used to turn a list constructed off-chain into a `Dict`\n which has taken care of maintaining interval invariants. This function still\n performs a sanity check on all keys to avoid silly mistakes. It is, however,\n considerably faster than [&#39;from_pairs&#39;](from_pairs)","url":"aiken/collection/dict.html#from_ascending_pairs"},{"doc":"aiken/collection/dict","title":"from_ascending_pairs_with","content":"from_ascending_pairs_with(\n  xs: Pairs&lt;ByteArray, value&gt;,\n  predicate: fn(value) -&gt; Bool,\n) -&gt; Dict&lt;key, value&gt;\n Like [`from_ascending_pairs`](#from_ascending_pairs) but fails if **any**\n value doesn&#39;t satisfy the predicate.\n\n ```aiken\n let pairs = [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n\n dict.from_ascending_pairs_with(pairs, fn(x) { x &lt;= 250 }) // fail\n ```","url":"aiken/collection/dict.html#from_ascending_pairs_with"},{"doc":"aiken/collection/dict","title":"from_pairs","content":"from_pairs(self: Pairs&lt;ByteArray, value&gt;) -&gt; Dict&lt;key, value&gt;\n Construct a dictionary from a list of key-value pairs. Note that when a key is present\n multiple times, the first occurrence prevails.\n\n ```aiken\n let pairs = [Pair(&quot;a&quot;, 100), Pair(&quot;c&quot;, 300), Pair(&quot;b&quot;, 200)]\n\n let result =\n   dict.from_pairs(pairs)\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n ```","url":"aiken/collection/dict.html#from_pairs"},{"doc":"aiken/collection/dict","title":"find","content":"find(self: Dict&lt;key, value&gt;, value: value) -&gt; Option&lt;ByteArray&gt;\n Finds a value in the dictionary, and returns the first key found to have that value.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: 42)\n     |&gt; dict.insert(key: &quot;b&quot;, value: 14)\n     |&gt; dict.insert(key: &quot;c&quot;, value: 42)\n     |&gt; dict.find(42)\n\n result == Some(&quot;a&quot;)\n ```","url":"aiken/collection/dict.html#find"},{"doc":"aiken/collection/dict","title":"get","content":"get(self: Dict&lt;key, value&gt;, key: ByteArray) -&gt; Option&lt;value&gt;\n Get a value in the dict by its key.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: &quot;Aiken&quot;)\n     |&gt; dict.get(key: &quot;a&quot;)\n\n  result == Some(&quot;Aiken&quot;)\n ```","url":"aiken/collection/dict.html#get"},{"doc":"aiken/collection/dict","title":"has_key","content":"has_key(self: Dict&lt;key, value&gt;, key: ByteArray) -&gt; Bool\n Check if a key exists in the dictionary.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: &quot;Aiken&quot;)\n     |&gt; dict.has_key(&quot;a&quot;)\n\n result == True\n ```","url":"aiken/collection/dict.html#has_key"},{"doc":"aiken/collection/dict","title":"is_empty","content":"is_empty(self: Dict&lt;key, value&gt;) -&gt; Bool\n Efficiently checks whether a dictionary is empty.\n ```aiken\n dict.is_empty(dict.new()) == True\n ```","url":"aiken/collection/dict.html#is_empty"},{"doc":"aiken/collection/dict","title":"keys","content":"keys(self: Dict&lt;key, value&gt;) -&gt; List&lt;ByteArray&gt;\n Extract all the keys present in a given `Dict`.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(&quot;a&quot;, 14)\n     |&gt; dict.insert(&quot;b&quot;, 42)\n     |&gt; dict.insert(&quot;a&quot;, 1337)\n     |&gt; dict.keys()\n\n result == [&quot;a&quot;, &quot;b&quot;]\n ```","url":"aiken/collection/dict.html#keys"},{"doc":"aiken/collection/dict","title":"size","content":"size(self: Dict&lt;key, value&gt;) -&gt; Int\n Return the number of key-value pairs in the dictionary.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(&quot;a&quot;, 100)\n     |&gt; dict.insert(&quot;b&quot;, 200)\n     |&gt; dict.insert(&quot;c&quot;, 300)\n     |&gt; dict.size()\n\n result == 3\n ```","url":"aiken/collection/dict.html#size"},{"doc":"aiken/collection/dict","title":"values","content":"values(self: Dict&lt;key, value&gt;) -&gt; List&lt;value&gt;\n Extract all the values present in a given `Dict`.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(&quot;a&quot;, 14)\n     |&gt; dict.insert(&quot;b&quot;, 42)\n     |&gt; dict.insert(&quot;c&quot;, 1337)\n     |&gt; dict.values()\n\n result == [1337, 42]\n ```","url":"aiken/collection/dict.html#values"},{"doc":"aiken/collection/dict","title":"delete","content":"delete(self: Dict&lt;key, value&gt;, key: ByteArray) -&gt; Dict&lt;key, value&gt;\n Remove a key-value pair from the dictionary. If the key is not found, no changes are made.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: 100)\n     |&gt; dict.insert(key: &quot;b&quot;, value: 200)\n     |&gt; dict.delete(key: &quot;a&quot;)\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;b&quot;, 200)]\n ```","url":"aiken/collection/dict.html#delete"},{"doc":"aiken/collection/dict","title":"filter","content":"filter(\n  self: Dict&lt;key, value&gt;,\n  with: fn(ByteArray, value) -&gt; Bool,\n) -&gt; Dict&lt;key, value&gt;\n Keep only the key-value pairs that pass the given predicate.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: 100)\n     |&gt; dict.insert(key: &quot;b&quot;, value: 200)\n     |&gt; dict.insert(key: &quot;c&quot;, value: 300)\n     |&gt; dict.filter(fn(k, _v) { k != &quot;a&quot; })\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n ```","url":"aiken/collection/dict.html#filter"},{"doc":"aiken/collection/dict","title":"insert","content":"insert(self: Dict&lt;key, value&gt;, key: ByteArray, value: value) -&gt; Dict&lt;key, value&gt;\n Insert a value in the dictionary at a given key. If the key already exists, its value is **overridden**. If you need ways to combine keys together, use (`insert_with`)[#insert_with].\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: 1)\n     |&gt; dict.insert(key: &quot;b&quot;, value: 2)\n     |&gt; dict.insert(key: &quot;a&quot;, value: 3)\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 3), Pair(&quot;b&quot;, 2)]\n ```","url":"aiken/collection/dict.html#insert"},{"doc":"aiken/collection/dict","title":"insert_with","content":"insert_with(\n  self: Dict&lt;key, value&gt;,\n  key: ByteArray,\n  value: value,\n  with: fn(ByteArray, value, value) -&gt; Option&lt;value&gt;,\n) -&gt; Dict&lt;key, value&gt;\n Insert a value in the dictionary at a given key. When the key already exist, the provided\n merge function is called. The value existing in the dictionary is passed as the second argument\n to the merge function, and the new value is passed as the third argument.\n\n ```aiken\n let sum =\n   fn (_k, a, b) { Some(a + b) }\n\n let result =\n   dict.new()\n     |&gt; dict.insert_with(key: &quot;a&quot;, value: 1, with: sum)\n     |&gt; dict.insert_with(key: &quot;b&quot;, value: 2, with: sum)\n     |&gt; dict.insert_with(key: &quot;a&quot;, value: 3, with: sum)\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 4), Pair(&quot;b&quot;, 2)]\n ```","url":"aiken/collection/dict.html#insert_with"},{"doc":"aiken/collection/dict","title":"map","content":"map(self: Dict&lt;key, a&gt;, with: fn(ByteArray, a) -&gt; b) -&gt; Dict&lt;key, b&gt;\n Apply a function to all key-value pairs in a Dict.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(&quot;a&quot;, 100)\n     |&gt; dict.insert(&quot;b&quot;, 200)\n     |&gt; dict.insert(&quot;c&quot;, 300)\n     |&gt; dict.map(fn(_k, v) { v * 2 })\n     |&gt; dict.to_pairs()\n\n  result == [Pair(&quot;a&quot;, 200), Pair(&quot;b&quot;, 400), Pair(&quot;c&quot;, 600)]\n ```","url":"aiken/collection/dict.html#map"},{"doc":"aiken/collection/dict","title":"union","content":"union(left: Dict&lt;key, value&gt;, right: Dict&lt;key, value&gt;) -&gt; Dict&lt;key, value&gt;\n Combine two dictionaries. If the same key exist in both the left and\n right dictionary, values from the left are preferred (i.e. left-biaised).\n\n ```aiken\n let left_dict = dict.from_pairs([Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200)])\n let right_dict = dict.from_pairs([Pair(&quot;a&quot;, 150), Pair(&quot;c&quot;, 300)])\n\n let result =\n   dict.union(left_dict, right_dict) |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n ```","url":"aiken/collection/dict.html#union"},{"doc":"aiken/collection/dict","title":"union_with","content":"union_with(\n  left: Dict&lt;key, value&gt;,\n  right: Dict&lt;key, value&gt;,\n  with: fn(ByteArray, value, value) -&gt; Option&lt;value&gt;,\n) -&gt; Dict&lt;key, value&gt;\n Like [`union`](#union) but allows specifying the behavior to adopt when a key is present\n in both dictionaries. The first value received correspond to the value in the left\n dictionnary, whereas the second argument corresponds to the value in the right dictionnary.\n\n When passing `None`, the value is removed and not present in the union.\n\n ```aiken\n let left_dict = dict.from_pairs([Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200)])\n let right_dict = dict.from_pairs([Pair(&quot;a&quot;, 150), Pair(&quot;c&quot;, 300)])\n\n let result =\n   dict.union_with(\n     left_dict,\n     right_dict,\n     fn(_k, v1, v2) { Some(v1 + v2) },\n   )\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 250), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n ```","url":"aiken/collection/dict.html#union_with"},{"doc":"aiken/collection/dict","title":"foldl","content":"foldl(\n  self: Dict&lt;key, value&gt;,\n  zero: result,\n  with: fn(ByteArray, value, result) -&gt; result,\n) -&gt; result\n Fold over the key-value pairs in a dictionary. The fold direction follows keys\n in ascending order and is done from left-to-right.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: 100)\n     |&gt; dict.insert(key: &quot;b&quot;, value: 200)\n     |&gt; dict.insert(key: &quot;c&quot;, value: 300)\n     |&gt; dict.foldl(0, fn(_k, v, r) { v + r })\n\n result == 600\n ```","url":"aiken/collection/dict.html#foldl"},{"doc":"aiken/collection/dict","title":"foldr","content":"foldr(\n  self: Dict&lt;key, value&gt;,\n  zero: result,\n  with: fn(ByteArray, value, result) -&gt; result,\n) -&gt; result\n Fold over the key-value pairs in a dictionary. The fold direction follows keys\n in ascending order and is done from right-to-left.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(key: &quot;a&quot;, value: 100)\n     |&gt; dict.insert(key: &quot;b&quot;, value: 200)\n     |&gt; dict.insert(key: &quot;c&quot;, value: 300)\n     |&gt; dict.foldr(0, fn(_k, v, r) { v + r })\n\n result == 600\n ```","url":"aiken/collection/dict.html#foldr"},{"doc":"aiken/collection/dict","title":"to_pairs","content":"to_pairs(self: Dict&lt;key, value&gt;) -&gt; Pairs&lt;ByteArray, value&gt;\n Get the inner list holding the dictionary data.\n\n ```aiken\n let result =\n   dict.new()\n     |&gt; dict.insert(&quot;a&quot;, 100)\n     |&gt; dict.insert(&quot;b&quot;, 200)\n     |&gt; dict.insert(&quot;c&quot;, 300)\n     |&gt; dict.to_pairs()\n\n result == [Pair(&quot;a&quot;, 100), Pair(&quot;b&quot;, 200), Pair(&quot;c&quot;, 300)]\n ```","url":"aiken/collection/dict.html#to_pairs"},{"doc":"aiken/collection/dict","title":"Dict","content":"Dict&lt;key, value&gt;\n An opaque `Dict`. The type is opaque because the module maintains some\n invariant, namely: there&#39;s only one occurrence of a given key in the dictionary.\n\n Note that the `key` parameter is a phantom-type, and only present as a\n means of documentation. Keys can be any type, yet will need to comparable\n to use functions like `insert`.\n\n See for example:\n\n ```aiken\n pub type Value =\n   Dict&lt;PolicyId, Dict&lt;AssetName, Int&gt;&gt;\n ```\n","url":"aiken/collection/dict.html#Dict"},{"doc":"aiken/collection/dict","title":"aiken/collection/dict","content":" A module for working with bytearray dictionaries.\n\n\n &gt; [!IMPORTANT]\n &gt;\n &gt; Dictionaries are **ordered sets** of key-value pairs, which thus\n &gt; preserve some invariants. Specifically, each key is only present once in\n &gt; the dictionary and all keys are stored in ascending lexicographic order.\n &gt;\n &gt; These invariants allow for more optimized functions to operate on `Dict`,\n &gt; but as a trade-offs, prevent `Dict` from being serializable. To recover a `Dict`\n &gt; from an unknown `Data`, you must first recover an `Pairs&lt;k, v&gt;` and use\n &gt; [`dict.from_ascending_list`](#from_ascending_list).","url":"aiken/collection/dict.html"},{"doc":"aiken/crypto","title":"blake2b_224","content":"blake2b_224(bytes: ByteArray) -&gt; Hash&lt;Blake2b_224, a&gt;\n Compute the blake2b-224 hash digest (28 bytes) of some data.","url":"aiken/crypto.html#blake2b_224"},{"doc":"aiken/crypto","title":"blake2b_256","content":"blake2b_256(bytes: ByteArray) -&gt; Hash&lt;Blake2b_256, a&gt;\n Compute the blake2b-256 hash digest (32 bytes) of some data.","url":"aiken/crypto.html#blake2b_256"},{"doc":"aiken/crypto","title":"keccak_256","content":"keccak_256(bytes: ByteArray) -&gt; Hash&lt;Keccak_256, a&gt;\n Compute the keccak-256 hash digest (32 bytes) of some data.","url":"aiken/crypto.html#keccak_256"},{"doc":"aiken/crypto","title":"sha2_256","content":"sha2_256(bytes: ByteArray) -&gt; Hash&lt;Sha2_256, a&gt;\n Compute the sha2-256 hash digest (32 bytes) of some data.","url":"aiken/crypto.html#sha2_256"},{"doc":"aiken/crypto","title":"sha3_256","content":"sha3_256(bytes: ByteArray) -&gt; Hash&lt;Sha3_256, a&gt;\n Compute the sha3-256 hash digest (32 bytes) of some data.","url":"aiken/crypto.html#sha3_256"},{"doc":"aiken/crypto","title":"verify_ecdsa_signature","content":"verify_ecdsa_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -&gt; Bool\n Verify an ECDCA signature (over secp256k1) using the given verification key.\n Returns `True` when the signature is valid.","url":"aiken/crypto.html#verify_ecdsa_signature"},{"doc":"aiken/crypto","title":"verify_ed25519_signature","content":"verify_ed25519_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -&gt; Bool\n Verify an Ed25519 signature using the given verification key.\n Returns `True` when the signature is valid.","url":"aiken/crypto.html#verify_ed25519_signature"},{"doc":"aiken/crypto","title":"verify_schnorr_signature","content":"verify_schnorr_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -&gt; Bool\n Verify a Schnorr signature (over secp256k1) using the given verification key.\n Returns `True` when the signature is valid.","url":"aiken/crypto.html#verify_schnorr_signature"},{"doc":"aiken/crypto","title":"Blake2b_224","content":"Blake2b_224\n A blake2b-224 hash algorithm.\n\n Typically used for:\n\n - [`Credential`](../cardano/address.html#Credential)\n - [`PolicyId`](../cardano/assets.html#PolicyId)\n\n Note: there&#39;s no function to calculate blake2b-224 hash digests on-chain.\n","url":"aiken/crypto.html#Blake2b_224"},{"doc":"aiken/crypto","title":"Blake2b_256","content":"Blake2b_256\n A blake2b-256 hash algorithm.\n\n Typically used for:\n\n - [`TransactionId`](../cardano/transaction.html#TransactionId)\n","url":"aiken/crypto.html#Blake2b_256"},{"doc":"aiken/crypto","title":"DataHash","content":"DataHash = Hash&lt;Blake2b_256, Data&gt;\n\n","url":"aiken/crypto.html#DataHash"},{"doc":"aiken/crypto","title":"Hash","content":"Hash&lt;alg, a&gt; = ByteArray\n A `Hash` is nothing more than a `ByteArray`, but it carries extra\n information for readability.\n\n On-chain, any hash digest value is represented as a plain &#39;ByteArray&#39;.\n Though in practice, hashes come from different sources and have\n different semantics.\n\n Hence, while this type-alias doesn&#39;t provide any strong type-guarantees,\n it helps writing functions signatures with more meaningful types than mere\n &#39;ByteArray&#39;.\n\n Compare for example:\n\n ```aiken\n pub type Credential {\n   VerificationKey(ByteArray)\n   Script(ByteArray)\n }\n ```\n\n with\n\n ```aiken\n pub type Credential {\n   VerificationKey(Hash&lt;Blake2b_224, VerificationKey&gt;)\n   Script(Hash&lt;Blake2b_224, Script&gt;)\n }\n ```\n\n Both are strictly equivalent, but the second reads much better.\n","url":"aiken/crypto.html#Hash"},{"doc":"aiken/crypto","title":"Keccak_256","content":"Keccak_256\n A Keccak-256 hash algorithm.\n","url":"aiken/crypto.html#Keccak_256"},{"doc":"aiken/crypto","title":"Script","content":"Script = ByteArray\n\n","url":"aiken/crypto.html#Script"},{"doc":"aiken/crypto","title":"ScriptHash","content":"ScriptHash = Hash&lt;Blake2b_224, Script&gt;\n\n","url":"aiken/crypto.html#ScriptHash"},{"doc":"aiken/crypto","title":"Sha2_256","content":"Sha2_256\n A SHA2-256 hash algorithm.\n","url":"aiken/crypto.html#Sha2_256"},{"doc":"aiken/crypto","title":"Sha3_256","content":"Sha3_256\n A SHA3-256 hash algorithm.\n","url":"aiken/crypto.html#Sha3_256"},{"doc":"aiken/crypto","title":"Signature","content":"Signature = ByteArray\n\n","url":"aiken/crypto.html#Signature"},{"doc":"aiken/crypto","title":"VerificationKey","content":"VerificationKey = ByteArray\n\n","url":"aiken/crypto.html#VerificationKey"},{"doc":"aiken/crypto","title":"VerificationKeyHash","content":"VerificationKeyHash = Hash&lt;Blake2b_224, VerificationKey&gt;\n\n","url":"aiken/crypto.html#VerificationKeyHash"},{"doc":"aiken/crypto","title":"aiken/crypto","content":"","url":"aiken/crypto.html"}]);